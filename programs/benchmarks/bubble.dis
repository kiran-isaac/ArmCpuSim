
benchmarks/bubble.out:	file format elf32-littlearm

Disassembly of section .text:

00000000 <sbrk>:
; extern void* sbrk(ptrdiff_t increment) {
       0: b083         	sub	sp, #0xc
       2: 9001         	str	r0, [sp, #0x4]
;     char* prev_heap_ptr = heap_ptr;
       4: 480f         	ldr	r0, [pc, #0x3c]         @ 0x44 <sbrk+0x44>
       6: 6800         	ldr	r0, [r0]
       8: 9000         	str	r0, [sp]
;     if (increment > 0) {
       a: 9801         	ldr	r0, [sp, #0x4]
       c: 2801         	cmp	r0, #0x1
       e: db12         	blt	0x36 <sbrk+0x36>        @ imm = #0x24
      10: e7ff         	b	0x12 <sbrk+0x12>        @ imm = #-0x2
;         if (heap_ptr + increment > &__heap_end) {
      12: 480c         	ldr	r0, [pc, #0x30]         @ 0x44 <sbrk+0x44>
      14: 6800         	ldr	r0, [r0]
      16: 9901         	ldr	r1, [sp, #0x4]
      18: 1840         	adds	r0, r0, r1
      1a: 490b         	ldr	r1, [pc, #0x2c]         @ 0x48 <sbrk+0x48>
      1c: 4288         	cmp	r0, r1
      1e: d904         	bls	0x2a <sbrk+0x2a>        @ imm = #0x8
      20: e7ff         	b	0x22 <sbrk+0x22>        @ imm = #-0x2
      22: 2000         	movs	r0, #0x0
      24: 43c0         	mvns	r0, r0
;             return (void*)-1;  // Return error if the heap is full
      26: 9002         	str	r0, [sp, #0x8]
      28: e008         	b	0x3c <sbrk+0x3c>        @ imm = #0x10
;         heap_ptr += increment;
      2a: 9a01         	ldr	r2, [sp, #0x4]
      2c: 4905         	ldr	r1, [pc, #0x14]         @ 0x44 <sbrk+0x44>
      2e: 6808         	ldr	r0, [r1]
      30: 1880         	adds	r0, r0, r2
      32: 6008         	str	r0, [r1]
;     }
      34: e7ff         	b	0x36 <sbrk+0x36>        @ imm = #-0x2
;     return (void*)prev_heap_ptr;
      36: 9800         	ldr	r0, [sp]
      38: 9002         	str	r0, [sp, #0x8]
      3a: e7ff         	b	0x3c <sbrk+0x3c>        @ imm = #-0x2
; }
      3c: 9802         	ldr	r0, [sp, #0x8]
      3e: b003         	add	sp, #0xc
      40: 4770         	bx	lr
      42: 46c0         	mov	r8, r8
      44: 00 00 00 20  	.word	0x20000000
      48: 00 00 f8 21  	.word	0x21f80000

0000004c <swap>:
; void swap(char *arr, int i, int j) {
      4c: b084         	sub	sp, #0x10
      4e: 9003         	str	r0, [sp, #0xc]
      50: 9102         	str	r1, [sp, #0x8]
      52: 9201         	str	r2, [sp, #0x4]
;   int temp = arr[i];
      54: 9803         	ldr	r0, [sp, #0xc]
      56: 9902         	ldr	r1, [sp, #0x8]
      58: 5c40         	ldrb	r0, [r0, r1]
      5a: 9000         	str	r0, [sp]
;   arr[i] = arr[j];
      5c: 9903         	ldr	r1, [sp, #0xc]
      5e: 9801         	ldr	r0, [sp, #0x4]
      60: 5c08         	ldrb	r0, [r1, r0]
      62: 9a02         	ldr	r2, [sp, #0x8]
      64: 5488         	strb	r0, [r1, r2]
;   arr[j] = temp;
      66: 9800         	ldr	r0, [sp]
      68: 9903         	ldr	r1, [sp, #0xc]
      6a: 9a01         	ldr	r2, [sp, #0x4]
      6c: 5488         	strb	r0, [r1, r2]
; }
      6e: b004         	add	sp, #0x10
      70: 4770         	bx	lr

00000072 <bubble_sort>:
; void bubble_sort(char arr[], int n) {
      72: b580         	push	{r7, lr}
      74: af00         	add	r7, sp, #0x0
      76: b084         	sub	sp, #0x10
      78: 9003         	str	r0, [sp, #0xc]
      7a: 9102         	str	r1, [sp, #0x8]
      7c: 2000         	movs	r0, #0x0
;   for (int i = 0; i < n; i++) {
      7e: 9001         	str	r0, [sp, #0x4]
      80: e7ff         	b	0x82 <bubble_sort+0x10> @ imm = #-0x2
      82: 9801         	ldr	r0, [sp, #0x4]
      84: 9902         	ldr	r1, [sp, #0x8]
      86: 4288         	cmp	r0, r1
      88: da23         	bge	0xd2 <bubble_sort+0x60> @ imm = #0x46
      8a: e7ff         	b	0x8c <bubble_sort+0x1a> @ imm = #-0x2
      8c: 2000         	movs	r0, #0x0
;     for (int j = 0; j < n - i - 1; j++) {
      8e: 9000         	str	r0, [sp]
      90: e7ff         	b	0x92 <bubble_sort+0x20> @ imm = #-0x2
      92: 9800         	ldr	r0, [sp]
      94: 9a02         	ldr	r2, [sp, #0x8]
      96: 9901         	ldr	r1, [sp, #0x4]
      98: 43c9         	mvns	r1, r1
      9a: 1889         	adds	r1, r1, r2
      9c: 4288         	cmp	r0, r1
      9e: da13         	bge	0xc8 <bubble_sort+0x56> @ imm = #0x26
      a0: e7ff         	b	0xa2 <bubble_sort+0x30> @ imm = #-0x2
;       if (arr[j] > arr[j + 1])
      a2: 9803         	ldr	r0, [sp, #0xc]
      a4: 9a00         	ldr	r2, [sp]
      a6: 1881         	adds	r1, r0, r2
      a8: 5c80         	ldrb	r0, [r0, r2]
      aa: 7849         	ldrb	r1, [r1, #0x1]
      ac: 4288         	cmp	r0, r1
      ae: dd06         	ble	0xbe <bubble_sort+0x4c> @ imm = #0xc
      b0: e7ff         	b	0xb2 <bubble_sort+0x40> @ imm = #-0x2
;         swap(arr, j, j + 1);
      b2: 9803         	ldr	r0, [sp, #0xc]
      b4: 9900         	ldr	r1, [sp]
      b6: 1c4a         	adds	r2, r1, #0x1
      b8: f7ff ffc8    	bl	0x4c <swap>             @ imm = #-0x70
      bc: e7ff         	b	0xbe <bubble_sort+0x4c> @ imm = #-0x2
;     }
      be: e7ff         	b	0xc0 <bubble_sort+0x4e> @ imm = #-0x2
;     for (int j = 0; j < n - i - 1; j++) {
      c0: 9800         	ldr	r0, [sp]
      c2: 1c40         	adds	r0, r0, #0x1
      c4: 9000         	str	r0, [sp]
      c6: e7e4         	b	0x92 <bubble_sort+0x20> @ imm = #-0x38
;   }
      c8: e7ff         	b	0xca <bubble_sort+0x58> @ imm = #-0x2
;   for (int i = 0; i < n; i++) {
      ca: 9801         	ldr	r0, [sp, #0x4]
      cc: 1c40         	adds	r0, r0, #0x1
      ce: 9001         	str	r0, [sp, #0x4]
      d0: e7d7         	b	0x82 <bubble_sort+0x10> @ imm = #-0x52
; }
      d2: b004         	add	sp, #0x10
      d4: bd80         	pop	{r7, pc}

000000d6 <assert_is_sorted>:
; void assert_is_sorted(char *arr, unsigned n) {
      d6: b580         	push	{r7, lr}
      d8: af00         	add	r7, sp, #0x0
      da: b084         	sub	sp, #0x10
      dc: 9003         	str	r0, [sp, #0xc]
      de: 9102         	str	r1, [sp, #0x8]
      e0: 2000         	movs	r0, #0x0
;   for (int i = 0; i < n - 1; i++) {
      e2: 9001         	str	r0, [sp, #0x4]
      e4: e7ff         	b	0xe6 <assert_is_sorted+0x10> @ imm = #-0x2
      e6: 9801         	ldr	r0, [sp, #0x4]
      e8: 9902         	ldr	r1, [sp, #0x8]
      ea: 1e49         	subs	r1, r1, #0x1
      ec: 4288         	cmp	r0, r1
      ee: d211         	bhs	0x114 <assert_is_sorted+0x3e> @ imm = #0x22
      f0: e7ff         	b	0xf2 <assert_is_sorted+0x1c> @ imm = #-0x2
;     if (arr[i] > arr[i + 1]) {
      f2: 9803         	ldr	r0, [sp, #0xc]
      f4: 9a01         	ldr	r2, [sp, #0x4]
      f6: 1881         	adds	r1, r0, r2
      f8: 5c80         	ldrb	r0, [r0, r2]
      fa: 7849         	ldrb	r1, [r1, #0x1]
      fc: 4288         	cmp	r0, r1
      fe: dd04         	ble	0x10a <assert_is_sorted+0x34> @ imm = #0x8
     100: e7ff         	b	0x102 <assert_is_sorted+0x2c> @ imm = #-0x2
     102: 2001         	movs	r0, #0x1
;       svc_exit(1);
     104: f000 f808    	bl	0x118 <svc_exit>        @ imm = #0x10
;     }
     108: e7ff         	b	0x10a <assert_is_sorted+0x34> @ imm = #-0x2
;   }
     10a: e7ff         	b	0x10c <assert_is_sorted+0x36> @ imm = #-0x2
;   for (int i = 0; i < n - 1; i++) {
     10c: 9801         	ldr	r0, [sp, #0x4]
     10e: 1c40         	adds	r0, r0, #0x1
     110: 9001         	str	r0, [sp, #0x4]
     112: e7e8         	b	0xe6 <assert_is_sorted+0x10> @ imm = #-0x30
; }
     114: b004         	add	sp, #0x10
     116: bd80         	pop	{r7, pc}

00000118 <svc_exit>:
; static inline void svc_exit(unsigned code) {
     118: b082         	sub	sp, #0x8
     11a: 9001         	str	r0, [sp, #0x4]
;     register unsigned r0 __asm__("r0") = code;
     11c: 9801         	ldr	r0, [sp, #0x4]
     11e: 9000         	str	r0, [sp]
;     __asm volatile ("svc 0" :  : "r"(r0) : "memory");
     120: 9800         	ldr	r0, [sp]
     122: df00         	svc	#0x0
; };
     124: b002         	add	sp, #0x8
     126: 4770         	bx	lr

00000128 <main>:
; int main() {
     128: b580         	push	{r7, lr}
     12a: af00         	add	r7, sp, #0x0
     12c: b086         	sub	sp, #0x18
     12e: 2081         	movs	r0, #0x81
     130: 0041         	lsls	r1, r0, #0x1
     132: a803         	add	r0, sp, #0xc
;   char arr[] = {
     134: 9001         	str	r0, [sp, #0x4]
     136: 8101         	strh	r1, [r0, #0x8]
     138: 4909         	ldr	r1, [pc, #0x24]         @ 0x160 <main+0x38>
     13a: 9104         	str	r1, [sp, #0x10]
     13c: 4909         	ldr	r1, [pc, #0x24]         @ 0x164 <main+0x3c>
     13e: 9103         	str	r1, [sp, #0xc]
     140: 210a         	movs	r1, #0xa
;   unsigned len = sizeof(arr) / sizeof(char);
     142: 9102         	str	r1, [sp, #0x8]
;   bubble_sort(arr, len);
     144: 9902         	ldr	r1, [sp, #0x8]
     146: f7ff ff94    	bl	0x72 <bubble_sort>      @ imm = #-0xd8
     14a: 9801         	ldr	r0, [sp, #0x4]
;   assert_is_sorted(arr, len);
     14c: 9902         	ldr	r1, [sp, #0x8]
     14e: f7ff ffc2    	bl	0xd6 <assert_is_sorted> @ imm = #-0x7c
     152: 9801         	ldr	r0, [sp, #0x4]
;   svc_exit(arr[0]);
     154: 7800         	ldrb	r0, [r0]
     156: f7ff ffdf    	bl	0x118 <svc_exit>        @ imm = #-0x42
     15a: 2000         	movs	r0, #0x0
; }
     15c: b006         	add	sp, #0x18
     15e: bd80         	pop	{r7, pc}
     160: 06 05 04 03  	.word	0x03040506
     164: 0a 09 08 07  	.word	0x0708090a

Disassembly of section .rodata:

00000168 <.rodata>:
     168: 090a         	lsrs	r2, r1, #0x4
     16a: 0708         	lsls	r0, r1, #0x1c
     16c: 0506         	lsls	r6, r0, #0x14
     16e: 0304         	lsls	r4, r0, #0xc
     170: 0102         	lsls	r2, r0, #0x4

Disassembly of section .data:

20000000 <heap_ptr>:
20000000: 0008         	movs	r0, r1
20000002: 2000         	movs	r0, #0x0
20000004: 0000         	movs	r0, r0
20000006: 0000         	movs	r0, r0

Disassembly of section .heap:

20000008 <.heap>:
...

Disassembly of section .stack:

20080008 <.stack>:
...

Disassembly of section .comment:

00000000 <.comment>:
; extern void* sbrk(ptrdiff_t increment) {
       0: 6300         	str	r0, [r0, #0x30]
       2: 616c         	str	r4, [r5, #0x14]
;     char* prev_heap_ptr = heap_ptr;
       4: 676e         	str	r6, [r5, #0x74]
       6: 7620         	strb	r0, [r4, #0x18]
       8: 7265         	strb	r5, [r4, #0x9]
;     if (increment > 0) {
       a: 6973         	ldr	r3, [r6, #0x14]
       c: 6e6f         	ldr	r7, [r5, #0x64]
       e: 3120         	adds	r1, #0x20
      10: 2e39         	cmp	r6, #0x39
;         if (heap_ptr + increment > &__heap_end) {
      12: 2e31         	cmp	r6, #0x31
      14: 0035         	movs	r5, r6
      16: 694c         	ldr	r4, [r1, #0x14]
      18: 6b6e         	ldr	r6, [r5, #0x34]
      1a: 7265         	strb	r5, [r4, #0x9]
      1c: 203a         	movs	r0, #0x3a
      1e: 4c4c         	ldr	r4, [pc, #0x130]        @ 0x150 <main+0x28>
      20: 2044         	movs	r0, #0x44
      22: 3931         	subs	r1, #0x31
      24: 312e         	adds	r1, #0x2e
;             return (void*)-1;  // Return error if the heap is full
      26: 352e         	adds	r5, #0x2e
      28: 00           	<unknown>

Disassembly of section .debug_info:

00000000 <.debug_info>:
; extern void* sbrk(ptrdiff_t increment) {
       0: 0175         	lsls	r5, r6, #0x5
       2: 0000         	movs	r0, r0
;     char* prev_heap_ptr = heap_ptr;
       4: 0005         	movs	r5, r0
       6: 0401         	lsls	r1, r0, #0x10
       8: 0000         	movs	r0, r0
;     if (increment > 0) {
       a: 0000         	movs	r0, r0
       c: 0001         	movs	r1, r0
       e: 001d         	movs	r5, r3
      10: 0801         	lsrs	r1, r0, #0x20
;         if (heap_ptr + increment > &__heap_end) {
      12: 0000         	movs	r0, r0
      14: 0000         	movs	r0, r0
      16: 0000         	movs	r0, r0
      18: 0200         	lsls	r0, r0, #0x8
      1a: 6801         	ldr	r1, [r0]
      1c: 0001         	movs	r1, r0
      1e: 0800         	lsrs	r0, r0, #0x20
      20: 0000         	movs	r0, r0
      22: 0200         	lsls	r0, r0, #0x8
      24: 2e03         	cmp	r6, #0x3
;             return (void*)-1;  // Return error if the heap is full
      26: 0000         	movs	r0, r0
      28: 0100         	lsls	r0, r0, #0x4
;         heap_ptr += increment;
      2a: 0209         	lsls	r1, r1, #0x8
      2c: 00a1         	lsls	r1, r4, #0x2
      2e: 3303         	adds	r3, #0x3
      30: 0000         	movs	r0, r0
      32: 0400         	lsls	r0, r0, #0x10
;     }
      34: 0804         	lsrs	r4, r0, #0x20
;     return (void*)prev_heap_ptr;
      36: 0501         	lsls	r1, r0, #0x14
      38: 0106         	lsls	r6, r0, #0x4
      3a: 004c         	lsls	r4, r1, #0x1
; }
      3c: 0000         	movs	r0, r0
      3e: 5701         	ldrsb	r1, [r0, r4]
      40: 0105         	lsls	r5, r0, #0x4
      42: 371a         	adds	r7, #0x1a
      44: 0000         	movs	r0, r0
      46: 0700         	lsls	r0, r0, #0x1c
      48: 7d02         	ldrb	r2, [r0, #0x14]
      4a: 0c04         	lsrs	r4, r0, #0x10
; void swap(char *arr, int i, int j) {
      4c: 1a01         	subs	r1, r0, r0
      4e: 015c         	lsls	r4, r3, #0x5
      50: 0000         	movs	r0, r0
      52: 0208         	lsls	r0, r1, #0x8
;   int temp = arr[i];
      54: 007d         	lsls	r5, r7, #0x1
      56: 010e         	lsls	r6, r1, #0x4
      58: 2e1b         	cmp	r6, #0x1b
      5a: 0000         	movs	r0, r0
;   arr[i] = arr[j];
      5c: 0000         	movs	r0, r0
      5e: 0209         	lsls	r1, r1, #0x8
      60: 0026         	movs	r6, r4
      62: 0000         	movs	r0, r0
      64: 5701         	ldrsb	r1, [r0, r4]
;   arr[j] = temp;
      66: 0206         	lsls	r6, r0, #0x8
      68: 0703         	lsls	r3, r0, #0x1c
      6a: 7d02         	ldrb	r2, [r0, #0x14]
      6c: 0f0c         	lsrs	r4, r1, #0x1c
; }
      6e: 0302         	lsls	r2, r0, #0xc
      70: 002e         	movs	r6, r5
; void bubble_sort(char arr[], int n) {
      72: 0000         	movs	r0, r0
      74: 0207         	lsls	r7, r0, #0x8
      76: 087d         	lsrs	r5, r7, #0x1
      78: 0210         	lsls	r0, r2, #0x8
      7a: 5803         	ldr	r3, [r0, r0]
      7c: 0001         	movs	r1, r0
;   for (int i = 0; i < n; i++) {
      7e: 0700         	lsls	r0, r0, #0x1c
      80: 7d02         	ldrb	r2, [r0, #0x14]
      82: 1104         	asrs	r4, r0, #0x4
      84: 0302         	lsls	r2, r0, #0xc
      86: 0158         	lsls	r0, r3, #0x5
      88: 0000         	movs	r0, r0
      8a: 0208         	lsls	r0, r1, #0x8
      8c: 007d         	lsls	r5, r7, #0x1
;     for (int j = 0; j < n - i - 1; j++) {
      8e: 0212         	lsls	r2, r2, #0x8
      90: 5804         	ldr	r4, [r0, r0]
      92: 0001         	movs	r1, r0
      94: 0000         	movs	r0, r0
      96: 0309         	lsls	r1, r1, #0xc
      98: 0064         	lsls	r4, r4, #0x1
      9a: 0000         	movs	r0, r0
      9c: 5701         	ldrsb	r1, [r0, r4]
      9e: 0207         	lsls	r7, r0, #0x8
      a0: 0709         	lsls	r1, r1, #0x1c
;       if (arr[j] > arr[j + 1])
      a2: 7d02         	ldrb	r2, [r0, #0x14]
      a4: 0f0c         	lsrs	r4, r1, #0x1c
      a6: 0902         	lsrs	r2, r0, #0x4
      a8: 002e         	movs	r6, r5
      aa: 0000         	movs	r0, r0
      ac: 0207         	lsls	r7, r0, #0x8
      ae: 087d         	lsrs	r5, r7, #0x1
      b0: 0213         	lsls	r3, r2, #0x8
;         swap(arr, j, j + 1);
      b2: 5809         	ldr	r1, [r1, r0]
      b4: 0001         	movs	r1, r0
      b6: 0a00         	lsrs	r0, r0, #0x8
      b8: 5404         	strb	r4, [r0, r0]
      ba: 0000         	movs	r0, r0
      bc: 0800         	lsrs	r0, r0, #0x20
;     }
      be: 7d02         	ldrb	r2, [r0, #0x14]
;     for (int j = 0; j < n - i - 1; j++) {
      c0: 1004         	asrs	r4, r0, #0x20
      c2: 0a02         	lsrs	r2, r0, #0x8
      c4: 0158         	lsls	r0, r3, #0x5
      c6: 0000         	movs	r0, r0
;   }
      c8: 050a         	lsls	r2, r1, #0x14
;   for (int i = 0; i < n; i++) {
      ca: 003a         	movs	r2, r7
      cc: 0000         	movs	r0, r0
      ce: 0208         	lsls	r0, r1, #0x8
      d0: 007d         	lsls	r5, r7, #0x1
; }
      d2: 0211         	lsls	r1, r2, #0x8
      d4: 580b         	ldr	r3, [r1, r0]
; void assert_is_sorted(char *arr, unsigned n) {
      d6: 0001         	movs	r1, r0
      d8: 0000         	movs	r0, r0
      da: 0000         	movs	r0, r0
      dc: 0609         	lsls	r1, r1, #0x18
      de: 0042         	lsls	r2, r0, #0x1
      e0: 0000         	movs	r0, r0
;   for (int i = 0; i < n - 1; i++) {
      e2: 5701         	ldrsb	r1, [r0, r4]
      e4: 0208         	lsls	r0, r1, #0x8
      e6: 0712         	lsls	r2, r2, #0x1c
      e8: 7d02         	ldrb	r2, [r0, #0x14]
      ea: 0f0c         	lsrs	r4, r1, #0x1c
      ec: 1202         	asrs	r2, r0, #0x8
      ee: 002e         	movs	r6, r5
      f0: 0000         	movs	r0, r0
;     if (arr[i] > arr[i + 1]) {
      f2: 0207         	lsls	r7, r0, #0x8
      f4: 087d         	lsrs	r5, r7, #0x1
      f6: 0213         	lsls	r3, r2, #0x8
      f8: 6412         	str	r2, [r2, #0x40]
      fa: 0001         	movs	r1, r0
      fc: 0a00         	lsrs	r0, r0, #0x8
      fe: 3207         	adds	r2, #0x7
     100: 0000         	movs	r0, r0
     102: 0800         	lsrs	r0, r0, #0x20
;       svc_exit(1);
     104: 7d02         	ldrb	r2, [r0, #0x14]
     106: 1004         	asrs	r4, r0, #0x20
;     }
     108: 1302         	asrs	r2, r0, #0xc
;   }
     10a: 0158         	lsls	r0, r3, #0x5
;   for (int i = 0; i < n - 1; i++) {
     10c: 0000         	movs	r0, r0
     10e: 0000         	movs	r0, r0
     110: 080b         	lsrs	r3, r1, #0x20
     112: 0010         	movs	r0, r2
; }
     114: 0000         	movs	r0, r0
     116: 5701         	ldrsb	r1, [r0, r4]
; static inline void svc_exit(unsigned code) {
     118: 0109         	lsls	r1, r1, #0x4
     11a: 070b         	lsls	r3, r1, #0x1c
;     register unsigned r0 __asm__("r0") = code;
     11c: 7d02         	ldrb	r2, [r0, #0x14]
     11e: 1504         	asrs	r4, r0, #0x14
;     __asm volatile ("svc 0" :  : "r"(r0) : "memory");
     120: 0b01         	lsrs	r1, r0, #0xc
     122: 0164         	lsls	r4, r4, #0x5
; };
     124: 0000         	movs	r0, r0
     126: 0208         	lsls	r0, r1, #0x8
; int main() {
     128: 007d         	lsls	r5, r7, #0x1
     12a: 0116         	lsls	r6, r2, #0x4
     12c: 640c         	str	r4, [r1, #0x40]
     12e: 0001         	movs	r1, r0
     130: 0000         	movs	r0, r0
     132: 090c         	lsrs	r4, r1, #0x4
;   char arr[] = {
     134: 0040         	lsls	r0, r0, #0x1
     136: 0000         	movs	r0, r0
     138: 5701         	ldrsb	r1, [r0, r4]
     13a: 020a         	lsls	r2, r1, #0x8
     13c: 581c         	ldr	r4, [r3, r0]
     13e: 0001         	movs	r1, r0
     140: 0800         	lsrs	r0, r0, #0x20
;   unsigned len = sizeof(arr) / sizeof(char);
     142: 7d02         	ldrb	r2, [r0, #0x14]
;   bubble_sort(arr, len);
     144: 0f0c         	lsrs	r4, r1, #0x1c
     146: 1d02         	adds	r2, r0, #0x4
     148: 0168         	lsls	r0, r5, #0x5
     14a: 0000         	movs	r0, r0
;   assert_is_sorted(arr, len);
     14c: 0208         	lsls	r0, r1, #0x8
     14e: 087d         	lsrs	r5, r7, #0x1
     150: 0218         	lsls	r0, r3, #0x8
     152: 6420         	str	r0, [r4, #0x40]
;   svc_exit(arr[0]);
     154: 0001         	movs	r1, r0
     156: 0000         	movs	r0, r0
     158: 0b04         	lsrs	r4, r0, #0xc
     15a: 0405         	lsls	r5, r0, #0x10
; }
     15c: 580d         	ldr	r5, [r1, r0]
     15e: 0001         	movs	r1, r0
     160: 0d00         	lsrs	r0, r0, #0x14
     162: 1203         	asrs	r3, r0, #0x8
     164: 1404         	asrs	r4, r0, #0x10
     166: 0407         	lsls	r7, r0, #0x10
     168: 330e         	adds	r3, #0xe
     16a: 0000         	movs	r0, r0
     16c: 0f00         	lsrs	r0, r0, #0x1c
     16e: 0174         	lsls	r4, r6, #0x5
     170: 0000         	movs	r0, r0
     172: 000a         	movs	r2, r1
     174: 1710         	asrs	r0, r2, #0x1c
     176: 0708         	lsls	r0, r1, #0x1c
     178: 00           	<unknown>

Disassembly of section .debug_abbrev:

00000000 <.debug_abbrev>:
; extern void* sbrk(ptrdiff_t increment) {
       0: 1101         	asrs	r1, r0, #0x4
       2: 2501         	movs	r5, #0x1
;     char* prev_heap_ptr = heap_ptr;
       4: 1325         	asrs	r5, r4, #0xc
       6: 0305         	lsls	r5, r0, #0xc
       8: 7225         	strb	r5, [r4, #0x8]
;     if (increment > 0) {
       a: 1017         	asrs	r7, r2, #0x20
       c: 1b17         	subs	r7, r2, r4
       e: 1125         	asrs	r5, r4, #0x4
      10: 121b         	asrs	r3, r3, #0x8
;         if (heap_ptr + increment > &__heap_end) {
      12: 7306         	strb	r6, [r0, #0xc]
      14: 0017         	movs	r7, r2
      16: 0200         	lsls	r0, r0, #0x8
      18: 0034         	movs	r4, r6
      1a: 2503         	movs	r5, #0x3
      1c: 1349         	asrs	r1, r1, #0xd
      1e: 0b3a         	lsrs	r2, r7, #0xc
      20: 0b3b         	lsrs	r3, r7, #0xc
      22: 1802         	adds	r2, r0, r0
      24: 0000         	movs	r0, r0
;             return (void*)-1;  // Return error if the heap is full
      26: 0f03         	lsrs	r3, r0, #0x1c
      28: 4900         	ldr	r1, [pc, #0x0]          @ 0x2c <.debug_info+0x2c>
;         heap_ptr += increment;
      2a: 0013         	movs	r3, r2
      2c: 0400         	lsls	r0, r0, #0x10
      2e: 0024         	movs	r4, r4
      30: 2503         	movs	r5, #0x3
      32: 0b3e         	lsrs	r6, r7, #0xc
;     }
      34: 0b0b         	lsrs	r3, r1, #0xc
;     return (void*)prev_heap_ptr;
      36: 0000         	movs	r0, r0
      38: 0f05         	lsrs	r5, r0, #0x1c
      3a: 0000         	movs	r0, r0
; }
      3c: 0600         	lsls	r0, r0, #0x18
      3e: 012e         	lsls	r6, r5, #0x4
      40: 1b11         	subs	r1, r2, r4
      42: 0612         	lsls	r2, r2, #0x18
      44: 1840         	adds	r0, r0, r1
      46: 2503         	movs	r5, #0x3
      48: 0b3a         	lsrs	r2, r7, #0xc
      4a: 0b3b         	lsrs	r3, r7, #0xc
; void swap(char *arr, int i, int j) {
      4c: 1927         	adds	r7, r4, r4
      4e: 1349         	asrs	r1, r1, #0xd
      50: 193f         	adds	r7, r7, r4
      52: 0000         	movs	r0, r0
;   int temp = arr[i];
      54: 0507         	lsls	r7, r0, #0x14
      56: 0200         	lsls	r0, r0, #0x8
      58: 0318         	lsls	r0, r3, #0xc
      5a: 3a25         	subs	r2, #0x25
;   arr[i] = arr[j];
      5c: 3b0b         	subs	r3, #0xb
      5e: 490b         	ldr	r1, [pc, #0x2c]         @ 0x8c <.debug_info+0x8c>
      60: 0013         	movs	r3, r2
      62: 0800         	lsrs	r0, r0, #0x20
      64: 0034         	movs	r4, r6
;   arr[j] = temp;
      66: 1802         	adds	r2, r0, r0
      68: 2503         	movs	r5, #0x3
      6a: 0b3a         	lsrs	r2, r7, #0xc
      6c: 0b3b         	lsrs	r3, r7, #0xc
; }
      6e: 1349         	asrs	r1, r1, #0xd
      70: 0000         	movs	r0, r0
; void bubble_sort(char arr[], int n) {
      72: 2e09         	cmp	r6, #0x9
      74: 1101         	asrs	r1, r0, #0x4
      76: 121b         	asrs	r3, r3, #0x8
      78: 4006         	ands	r6, r0
      7a: 0318         	lsls	r0, r3, #0xc
      7c: 3a25         	subs	r2, #0x25
;   for (int i = 0; i < n; i++) {
      7e: 3b0b         	subs	r3, #0xb
      80: 270b         	movs	r7, #0xb
      82: 3f19         	subs	r7, #0x19
      84: 0019         	movs	r1, r3
      86: 0a00         	lsrs	r0, r0, #0x8
      88: 010b         	lsls	r3, r1, #0x4
      8a: 1b11         	subs	r1, r2, r4
      8c: 0612         	lsls	r2, r2, #0x18
;     for (int j = 0; j < n - i - 1; j++) {
      8e: 0000         	movs	r0, r0
      90: 2e0b         	cmp	r6, #0xb
      92: 1101         	asrs	r1, r0, #0x4
      94: 121b         	asrs	r3, r3, #0x8
      96: 4006         	ands	r6, r0
      98: 0318         	lsls	r0, r3, #0xc
      9a: 3a25         	subs	r2, #0x25
      9c: 3b0b         	subs	r3, #0xb
      9e: 270b         	movs	r7, #0xb
      a0: 0019         	movs	r1, r3
;       if (arr[j] > arr[j + 1])
      a2: 0c00         	lsrs	r0, r0, #0x10
      a4: 012e         	lsls	r6, r5, #0x4
      a6: 1b11         	subs	r1, r2, r4
      a8: 0612         	lsls	r2, r2, #0x18
      aa: 1840         	adds	r0, r0, r1
      ac: 2503         	movs	r5, #0x3
      ae: 0b3a         	lsrs	r2, r7, #0xc
      b0: 0b3b         	lsrs	r3, r7, #0xc
;         swap(arr, j, j + 1);
      b2: 1349         	asrs	r1, r1, #0xd
      b4: 193f         	adds	r7, r7, r4
      b6: 0000         	movs	r0, r0
      b8: 160d         	asrs	r5, r1, #0x18
      ba: 4900         	ldr	r1, [pc, #0x0]          @ 0xbc <.debug_info+0xbc>
      bc: 0313         	lsls	r3, r2, #0xc
;     }
      be: 3a25         	subs	r2, #0x25
;     for (int j = 0; j < n - i - 1; j++) {
      c0: 3b0b         	subs	r3, #0xb
      c2: 000b         	movs	r3, r1
      c4: 0e00         	lsrs	r0, r0, #0x18
      c6: 0101         	lsls	r1, r0, #0x4
;   }
      c8: 1349         	asrs	r1, r1, #0xd
;   for (int i = 0; i < n; i++) {
      ca: 0000         	movs	r0, r0
      cc: 210f         	movs	r1, #0xf
      ce: 4900         	ldr	r1, [pc, #0x0]          @ 0xd0 <.debug_info+0xd0>
      d0: 3713         	adds	r7, #0x13
; }
      d2: 000b         	movs	r3, r1
      d4: 1000         	asrs	r0, r0, #0x20
; void assert_is_sorted(char *arr, unsigned n) {
      d6: 0024         	movs	r4, r4
      d8: 2503         	movs	r5, #0x3
      da: 0b0b         	lsrs	r3, r1, #0xc
      dc: 0b3e         	lsrs	r6, r7, #0xc
      de: 0000         	movs	r0, r0
      e0: 00           	<unknown>

Disassembly of section .debug_line:

00000000 <.debug_line>:
; extern void* sbrk(ptrdiff_t increment) {
       0: 020a         	lsls	r2, r1, #0x8
       2: 0000         	movs	r0, r0
;     char* prev_heap_ptr = heap_ptr;
       4: 0005         	movs	r5, r0
       6: 0004         	movs	r4, r0
       8: 0082         	lsls	r2, r0, #0x2
;     if (increment > 0) {
       a: 0000         	movs	r0, r0
       c: 0101         	lsls	r1, r0, #0x4
       e: fb01 0d0e    	<unknown>
;         if (heap_ptr + increment > &__heap_end) {
      12: 0100         	lsls	r0, r0, #0x4
      14: 0101         	lsls	r1, r0, #0x4
      16: 0001         	movs	r1, r0
      18: 0000         	movs	r0, r0
      1a: 0001         	movs	r1, r0
      1c: 0100         	lsls	r0, r0, #0x4
      1e: 0101         	lsls	r1, r0, #0x4
      20: 041f         	lsls	r7, r3, #0x10
      22: 0068         	lsls	r0, r5, #0x1
      24: 0000         	movs	r0, r0
;             return (void*)-1;  // Return error if the heap is full
      26: 0000         	movs	r0, r0
      28: 0000         	movs	r0, r0
;         heap_ptr += increment;
      2a: 0054         	lsls	r4, r2, #0x1
      2c: 0000         	movs	r0, r0
      2e: 0092         	lsls	r2, r2, #0x2
      30: 0000         	movs	r0, r0
      32: 0103         	lsls	r3, r0, #0x4
;     }
      34: 021f         	lsls	r7, r3, #0x8
;     return (void*)prev_heap_ptr;
      36: 050f         	lsls	r7, r1, #0x14
      38: 041e         	lsls	r6, r3, #0x10
      3a: 00a1         	lsls	r1, r4, #0x2
; }
      3c: 0000         	movs	r0, r0
      3e: 7600         	strb	r0, [r0, #0x18]
      40: 7616         	strb	r6, [r2, #0x18]
      42: 0447         	lsls	r7, r0, #0x11
      44: e27c         	b	0x540 <.rodata+0x3d8>   @ imm = #0x4f8
      46: b7e0         	<unknown>
      48: 35d3         	adds	r5, #0xd3
      4a: e7e3         	b	0x14 <.debug_line+0x14> @ imm = #-0x3a
; void swap(char *arr, int i, int j) {
      4c: 1b56         	subs	r6, r2, r5
      4e: b5be         	push	{r1, r2, r3, r4, r5, r7, lr}
      50: 0000         	movs	r0, r0
      52: 0100         	lsls	r0, r0, #0x4
;   int temp = arr[i];
      54: b4f9         	push	{r0, r3, r4, r5, r6, r7}
      56: 5110         	str	r0, [r2, r4]
      58: 81db         	strh	r3, [r3, #0xe]
      5a: 6976         	ldr	r6, [r6, #0x14]
;   arr[i] = arr[j];
      5c: a991         	add	r1, sp, #0x244
      5e: 3f64         	subs	r7, #0x64
      60: d53e         	bpl	0xe0 <.debug_line+0xe0> @ imm = #0x7c
      62: 01a9         	lsls	r1, r5, #0x6
      64: 005f         	lsls	r7, r3, #0x1
;   arr[j] = temp;
      66: 0000         	movs	r0, r0
      68: 7602         	strb	r2, [r0, #0x18]
      6a: 7616         	strb	r6, [r2, #0x18]
      6c: 0447         	lsls	r7, r0, #0x11
; }
      6e: e27c         	b	0x56a <.rodata+0x402>   @ imm = #0x4f8
      70: b7e0         	<unknown>
; void bubble_sort(char arr[], int n) {
      72: 35d3         	adds	r5, #0xd3
      74: e7e3         	b	0x3e <.debug_line+0x3e> @ imm = #-0x3a
      76: 1b56         	subs	r6, r2, r5
      78: 17be         	asrs	r6, r7, #0x1e
      7a: 0000         	movs	r0, r0
      7c: 0300         	lsls	r0, r0, #0xc
;   for (int i = 0; i < n; i++) {
      7e: d32e         	blo	0xde <.debug_line+0xde> @ imm = #0x5c
      80: 8947         	ldrh	r7, [r0, #0xa]
      82: 3e38         	subs	r6, #0x38
      84: e3a7         	b	0x7d6 <.rodata+0x66e>   @ imm = #0x74e
      86: d5a1         	bpl	0xffffffcc <.stack+0xffffffffdff7ffc4> @ imm = #-0xbe
      88: 0f88         	lsrs	r0, r1, #0x1e
      8a: c60f         	stm	r6!, {r0, r1, r2, r3}
      8c: 7197         	strb	r7, [r2, #0x6]
;     for (int j = 0; j < n - i - 1; j++) {
      8e: 0500         	lsls	r0, r0, #0x14
      90: 0002         	movs	r2, r0
      92: 0000         	movs	r0, r0
      94: 0300         	lsls	r0, r0, #0xc
      96: 0119         	lsls	r1, r3, #0x4
      98: 1b05         	subs	r5, r0, r4
      9a: 4b0a         	ldr	r3, [pc, #0x28]         @ 0xc4 <.debug_line+0xc4>
      9c: 0b05         	lsrs	r5, r0, #0xc
      9e: 4a06         	ldr	r2, [pc, #0x18]         @ 0xb8 <.debug_line+0xb8>
      a0: 0905         	lsrs	r5, r0, #0x4
;       if (arr[j] > arr[j + 1])
      a2: 3106         	adds	r1, #0x6
      a4: 2e06         	cmp	r6, #0x6
      a6: 0d05         	lsrs	r5, r0, #0x14
      a8: 6806         	ldr	r6, [r0]
      aa: 1805         	adds	r5, r0, r0
      ac: 4a06         	ldr	r2, [pc, #0x18]         @ 0xc8 <.debug_line+0xc8>
      ae: 1605         	asrs	r5, r0, #0x18
      b0: 052e         	lsls	r6, r5, #0x14
;         swap(arr, j, j + 1);
      b2: 2e22         	cmp	r6, #0x22
      b4: 0d05         	lsrs	r5, r0, #0x14
      b6: 032e         	lsls	r6, r5, #0xc
      b8: 6660         	str	r0, [r4, #0x64]
      ba: 0306         	lsls	r6, r0, #0xc
      bc: 4a21         	ldr	r2, [pc, #0x84]         @ 0x144 <.debug_line+0x144>
;     }
      be: 1505         	asrs	r5, r0, #0x14
;     for (int j = 0; j < n - i - 1; j++) {
      c0: 054e         	lsls	r6, r1, #0x15
      c2: 0612         	lsls	r2, r2, #0x18
      c4: 052e         	lsls	r6, r5, #0x14
      c6: 0605         	lsls	r5, r0, #0x18
;   }
      c8: 0583         	lsls	r3, r0, #0x16
;   for (int i = 0; i < n; i++) {
      ca: 3113         	adds	r1, #0x13
      cc: 0505         	lsls	r5, r0, #0x14
      ce: 2e06         	cmp	r6, #0x6
      d0: 0105         	lsls	r5, r0, #0x4
; }
      d2: 4b06         	ldr	r3, [pc, #0x18]         @ 0xec <.debug_line+0xec>
      d4: 0b06         	lsrs	r6, r0, #0xc
; void assert_is_sorted(char *arr, unsigned n) {
      d6: 032e         	lsls	r6, r5, #0xc
      d8: 6656         	str	r6, [r2, #0x64]
      da: 0204         	lsls	r4, r0, #0x8
      dc: 0005         	movs	r5, r0
      de: 8506         	strh	r6, [r0, #0x28]
      e0: 0e05         	lsrs	r5, r0, #0x18
;   for (int i = 0; i < n - 1; i++) {
      e2: 830a         	strh	r2, [r1, #0x18]
      e4: 1205         	asrs	r5, r0, #0x8
      e6: 2e06         	cmp	r6, #0x6
      e8: 0e05         	lsrs	r5, r0, #0x18
      ea: 052e         	lsls	r6, r5, #0x14
      ec: 2e07         	cmp	r6, #0x7
      ee: 0c05         	lsrs	r5, r0, #0x10
      f0: 2f06         	cmp	r7, #0x6
;     if (arr[i] > arr[i + 1]) {
      f2: 1005         	asrs	r5, r0, #0x20
      f4: 2e06         	cmp	r6, #0x6
      f6: 0c05         	lsrs	r5, r0, #0x10
      f8: 052e         	lsls	r6, r5, #0x14
      fa: 2e07         	cmp	r6, #0x7
      fc: 0a05         	lsrs	r5, r0, #0x8
      fe: 052e         	lsls	r6, r5, #0x14
     100: 060c         	lsls	r4, r1, #0x18
     102: 052f         	lsls	r7, r5, #0x14
;       svc_exit(1);
     104: 0603         	lsls	r3, r0, #0x18
     106: 052e         	lsls	r6, r5, #0x14
;     }
     108: 2e07         	cmp	r6, #0x7
;   }
     10a: 0a05         	lsrs	r5, r0, #0x8
;   for (int i = 0; i < n - 1; i++) {
     10c: 052e         	lsls	r6, r5, #0x14
     10e: 0601         	lsls	r1, r0, #0x18
     110: 2f0b         	cmp	r7, #0xb
     112: 0005         	movs	r5, r0
; }
     114: 054c         	lsls	r4, r1, #0x15
     116: 0a0c         	lsrs	r4, r1, #0x8
; static inline void svc_exit(unsigned code) {
     118: 05bb         	lsls	r3, r7, #0x16
     11a: 0608         	lsls	r0, r1, #0x18
;     register unsigned r0 __asm__("r0") = code;
     11c: 052e         	lsls	r6, r5, #0x14
     11e: 2e13         	cmp	r6, #0x13
;     __asm volatile ("svc 0" :  : "r"(r0) : "memory");
     120: 1705         	asrs	r5, r0, #0x1c
     122: 052e         	lsls	r6, r5, #0x14
; };
     124: 2e03         	cmp	r6, #0x3
     126: 7603         	strb	r3, [r0, #0x18]
; int main() {
     128: 0566         	lsls	r6, r4, #0x15
     12a: 060e         	lsls	r6, r1, #0x18
     12c: 0b03         	lsrs	r3, r0, #0xc
     12e: 052e         	lsls	r6, r5, #0x14
     130: 060a         	lsls	r2, r1, #0x18
     132: 052e         	lsls	r6, r5, #0x14
;   char arr[] = {
     134: 2e15         	cmp	r6, #0x15
     136: 1905         	adds	r5, r0, r4
     138: 052e         	lsls	r6, r5, #0x14
     13a: 2e1d         	cmp	r6, #0x1d
     13c: 1f05         	subs	r5, r0, #0x4
     13e: 052e         	lsls	r6, r5, #0x14
     140: 4a05         	ldr	r2, [pc, #0x14]         @ 0x158 <.debug_line+0x158>
;   unsigned len = sizeof(arr) / sizeof(char);
     142: 0b05         	lsrs	r5, r0, #0xc
;   bubble_sort(arr, len);
     144: 6706         	str	r6, [r0, #0x70]
     146: 0f05         	lsrs	r5, r0, #0x1c
     148: 2e06         	cmp	r6, #0x6
     14a: 0b05         	lsrs	r5, r0, #0xc
;   assert_is_sorted(arr, len);
     14c: 052e         	lsls	r6, r5, #0x14
     14e: 4a14         	ldr	r2, [pc, #0x50]         @ 0x1a0 <.rodata+0x38>
     150: 0b05         	lsrs	r5, r0, #0xc
     152: 052e         	lsls	r6, r5, #0x14
;   svc_exit(arr[0]);
     154: 060e         	lsls	r6, r1, #0x18
     156: 0567         	lsls	r7, r4, #0x15
     158: 0613         	lsls	r3, r2, #0x18
     15a: 052e         	lsls	r6, r5, #0x14
; }
     15c: 2e18         	cmp	r6, #0x18
     15e: 0905         	lsrs	r5, r0, #0x4
     160: 052e         	lsls	r6, r5, #0x14
     162: 0605         	lsls	r5, r0, #0x18
     164: 0567         	lsls	r7, r4, #0x15
     166: 2b25         	cmp	r3, #0x25
     168: 0505         	lsls	r5, r0, #0x14
     16a: 6606         	str	r6, [r0, #0x60]
     16c: 0305         	lsls	r5, r0, #0xc
     16e: 3206         	adds	r2, #0x6
     170: 1b05         	subs	r5, r0, r4
     172: 0529         	lsls	r1, r5, #0x14
     174: 0603         	lsls	r3, r0, #0x18
     176: 0566         	lsls	r6, r4, #0x15
     178: 0601         	lsls	r1, r0, #0x18
     17a: 340b         	adds	r4, #0xb
     17c: 0005         	movs	r5, r0
     17e: 054c         	lsls	r4, r1, #0x15
     180: 0a0c         	lsrs	r4, r1, #0x8
     182: 05bb         	lsls	r3, r7, #0x16
     184: 0608         	lsls	r0, r1, #0x18
     186: 052e         	lsls	r6, r5, #0x14
     188: 2e13         	cmp	r6, #0x13
     18a: 1705         	asrs	r5, r0, #0x1c
     18c: 052e         	lsls	r6, r5, #0x14
     18e: 2e19         	cmp	r6, #0x19
     190: 0305         	lsls	r5, r0, #0xc
     192: 052e         	lsls	r6, r5, #0x14
     194: 0609         	lsls	r1, r1, #0x18
     196: 0567         	lsls	r7, r4, #0x15
     198: 060d         	lsls	r5, r1, #0x18
     19a: 052e         	lsls	r6, r5, #0x14
     19c: 2e09         	cmp	r6, #0x9
     19e: 1205         	asrs	r5, r0, #0x8
     1a0: 054a         	lsls	r2, r1, #0x15
     1a2: 2e09         	cmp	r6, #0x9
     1a4: 6c03         	ldr	r3, [r0, #0x40]
     1a6: 0566         	lsls	r6, r4, #0x15
     1a8: 0607         	lsls	r7, r0, #0x18
     1aa: 1603         	asrs	r3, r0, #0x18
     1ac: 052e         	lsls	r6, r5, #0x14
     1ae: 4b05         	ldr	r3, [pc, #0x14]         @ 0x1c4 <.rodata+0x5c>
     1b0: 0305         	lsls	r5, r0, #0xc
     1b2: 052f         	lsls	r7, r5, #0x14
     1b4: 291f         	cmp	r1, #0x1f
     1b6: 0305         	lsls	r5, r0, #0xc
     1b8: 6606         	str	r6, [r0, #0x60]
     1ba: 0105         	lsls	r5, r0, #0x4
     1bc: 0b06         	lsrs	r6, r0, #0xc
     1be: 0435         	lsls	r5, r6, #0x10
     1c0: 0501         	lsls	r1, r0, #0x14
     1c2: 0300         	lsls	r0, r0, #0xc
     1c4: 4a71         	ldr	r2, [pc, #0x1c4]        @ 0x38c <.rodata+0x224>
     1c6: 2a05         	cmp	r2, #0x5
     1c8: 4b0a         	ldr	r3, [pc, #0x28]         @ 0x1f4 <.rodata+0x8c>
     1ca: 1705         	asrs	r5, r0, #0x1c
     1cc: 2e06         	cmp	r6, #0x6
     1ce: 2605         	movs	r6, #0x5
     1d0: 2f06         	cmp	r7, #0x6
     1d2: 0505         	lsls	r5, r0, #0x14
     1d4: 2e06         	cmp	r6, #0x6
     1d6: 0105         	lsls	r5, r0, #0x4
     1d8: 0b06         	lsrs	r6, r0, #0xc
     1da: 042f         	lsls	r7, r5, #0x10
     1dc: 0502         	lsls	r2, r0, #0x14
     1de: 0300         	lsls	r0, r0, #0xc
     1e0: 4a0e         	ldr	r2, [pc, #0x38]         @ 0x21c <.rodata+0xb4>
     1e2: 0805         	lsrs	r5, r0, #0x20
     1e4: bb0a         	<unknown>
     1e6: 0c05         	lsrs	r5, r0, #0x10
     1e8: 05d9         	lsls	r1, r3, #0x17
     1ea: 2f14         	cmp	r7, #0x14
     1ec: 0305         	lsls	r5, r0, #0xc
     1ee: 2e06         	cmp	r6, #0x6
     1f0: 1905         	adds	r5, r0, r4
     1f2: 6706         	str	r6, [r0, #0x70]
     1f4: 0305         	lsls	r5, r0, #0xc
     1f6: 2e06         	cmp	r6, #0x6
     1f8: 0c05         	lsrs	r5, r0, #0x10
     1fa: 6806         	ldr	r6, [r0]
     1fc: 0305         	lsls	r5, r0, #0xc
     1fe: 2e06         	cmp	r6, #0x6
     200: 0105         	lsls	r5, r0, #0x4
     202: 0b06         	lsrs	r6, r0, #0xc
     204: 0667         	lsls	r7, r4, #0x19
     206: 5b03         	ldrh	r3, [r0, r4]
     208: 024a         	lsls	r2, r1, #0x9
     20a: 0008         	movs	r0, r1
     20c: 0101         	lsls	r1, r0, #0x4

Disassembly of section .debug_frame:

00000000 <.debug_frame>:
; extern void* sbrk(ptrdiff_t increment) {
       0: 0010         	movs	r0, r2
       2: 0000         	movs	r0, r0
;     char* prev_heap_ptr = heap_ptr;
       4: ffff ffff    	<unknown>
       8: 0004         	movs	r4, r0
;     if (increment > 0) {
       a: 0004         	movs	r4, r0
       c: 7c01         	ldrb	r1, [r0, #0x10]
       e: 0c0e         	lsrs	r6, r1, #0x10
      10: 000d         	movs	r5, r1
;         if (heap_ptr + increment > &__heap_end) {
      12: 0000         	movs	r0, r0
      14: 0010         	movs	r0, r2
		...
      1e: 0000         	movs	r0, r0
      20: 004c         	lsls	r4, r1, #0x1
      22: 0000         	movs	r0, r0
      24: 0e42         	lsrs	r2, r0, #0x19
;             return (void*)-1;  // Return error if the heap is full
      26: 000c         	movs	r4, r1
      28: 0010         	movs	r0, r2
;         heap_ptr += increment;
      2a: 0000         	movs	r0, r0
      2c: 0000         	movs	r0, r0
      2e: 0000         	movs	r0, r0
      30: 004c         	lsls	r4, r1, #0x1
      32: 0000         	movs	r0, r0
;     }
      34: 0026         	movs	r6, r4
;     return (void*)prev_heap_ptr;
      36: 0000         	movs	r0, r0
      38: 0e42         	lsrs	r2, r0, #0x19
      3a: 0010         	movs	r0, r2
; }
      3c: 0018         	movs	r0, r3
      3e: 0000         	movs	r0, r0
      40: 0000         	movs	r0, r0
      42: 0000         	movs	r0, r0
      44: 0072         	lsls	r2, r6, #0x1
      46: 0000         	movs	r0, r0
      48: 0064         	lsls	r4, r4, #0x1
      4a: 0000         	movs	r0, r0
; void swap(char *arr, int i, int j) {
      4c: 0e42         	lsrs	r2, r0, #0x19
      4e: 8e08         	ldrh	r0, [r1, #0x30]
      50: 8701         	strh	r1, [r0, #0x38]
      52: 4202         	tst	r2, r0
;   int temp = arr[i];
      54: 070d         	lsls	r5, r1, #0x1c
      56: 0000         	movs	r0, r0
      58: 0018         	movs	r0, r3
      5a: 0000         	movs	r0, r0
;   arr[i] = arr[j];
      5c: 0000         	movs	r0, r0
      5e: 0000         	movs	r0, r0
      60: 00d6         	lsls	r6, r2, #0x3
      62: 0000         	movs	r0, r0
      64: 0042         	lsls	r2, r0, #0x1
;   arr[j] = temp;
      66: 0000         	movs	r0, r0
      68: 0e42         	lsrs	r2, r0, #0x19
      6a: 8e08         	ldrh	r0, [r1, #0x30]
      6c: 8701         	strh	r1, [r0, #0x38]
; }
      6e: 4202         	tst	r2, r0
      70: 070d         	lsls	r5, r1, #0x1c
; void bubble_sort(char arr[], int n) {
      72: 0000         	movs	r0, r0
      74: 0010         	movs	r0, r2
      76: 0000         	movs	r0, r0
      78: 0000         	movs	r0, r0
      7a: 0000         	movs	r0, r0
      7c: 0118         	lsls	r0, r3, #0x4
;   for (int i = 0; i < n; i++) {
      7e: 0000         	movs	r0, r0
      80: 0010         	movs	r0, r2
      82: 0000         	movs	r0, r0
      84: 0e42         	lsrs	r2, r0, #0x19
      86: 0008         	movs	r0, r1
      88: 0018         	movs	r0, r3
      8a: 0000         	movs	r0, r0
      8c: 0000         	movs	r0, r0
;     for (int j = 0; j < n - i - 1; j++) {
      8e: 0000         	movs	r0, r0
      90: 0128         	lsls	r0, r5, #0x4
      92: 0000         	movs	r0, r0
      94: 0040         	lsls	r0, r0, #0x1
      96: 0000         	movs	r0, r0
      98: 0e42         	lsrs	r2, r0, #0x19
      9a: 8e08         	ldrh	r0, [r1, #0x30]
      9c: 8701         	strh	r1, [r0, #0x38]
      9e: 4202         	tst	r2, r0
      a0: 070d         	lsls	r5, r1, #0x1c
;       if (arr[j] > arr[j + 1])
      a2: 0000         	movs	r0, r0

Disassembly of section .debug_str:

00000000 <.debug_str>:
; extern void* sbrk(ptrdiff_t increment) {
       0: 7361         	strb	r1, [r4, #0xd]
       2: 6573         	str	r3, [r6, #0x54]
;     char* prev_heap_ptr = heap_ptr;
       4: 7472         	strb	r2, [r6, #0x11]
       6: 695f         	ldr	r7, [r3, #0x14]
       8: 5f73         	ldrsh	r3, [r6, r5]
;     if (increment > 0) {
       a: 6f73         	ldr	r3, [r6, #0x74]
       c: 7472         	strb	r2, [r6, #0x11]
       e: 6465         	str	r5, [r4, #0x44]
      10: 6900         	ldr	r0, [r0, #0x10]
;         if (heap_ptr + increment > &__heap_end) {
      12: 636e         	str	r6, [r5, #0x34]
      14: 6572         	str	r2, [r6, #0x54]
      16: 656d         	str	r5, [r5, #0x54]
      18: 746e         	strb	r6, [r5, #0x11]
      1a: 6900         	ldr	r0, [r0, #0x10]
      1c: 6c00         	ldr	r0, [r0, #0x40]
      1e: 6e65         	ldr	r5, [r4, #0x64]
      20: 6300         	str	r0, [r0, #0x30]
      22: 646f         	str	r7, [r5, #0x44]
      24: 0065         	lsls	r5, r4, #0x1
;             return (void*)-1;  // Return error if the heap is full
      26: 7470         	strb	r0, [r6, #0x11]
      28: 6472         	str	r2, [r6, #0x44]
;         heap_ptr += increment;
      2a: 6669         	str	r1, [r5, #0x64]
      2c: 5f66         	ldrsh	r6, [r4, r5]
      2e: 0074         	lsls	r4, r6, #0x1
      30: 006e         	lsls	r6, r5, #0x1
      32: 7773         	strb	r3, [r6, #0x1d]
;     }
      34: 7061         	strb	r1, [r4, #0x1]
;     return (void*)prev_heap_ptr;
      36: 6300         	str	r0, [r0, #0x30]
      38: 616c         	str	r4, [r5, #0x14]
      3a: 676e         	str	r6, [r5, #0x74]
; }
      3c: 7620         	strb	r0, [r4, #0x18]
      3e: 7265         	strb	r5, [r4, #0x9]
      40: 6973         	ldr	r3, [r6, #0x14]
      42: 6e6f         	ldr	r7, [r5, #0x64]
      44: 3120         	adds	r1, #0x20
      46: 2e39         	cmp	r6, #0x39
      48: 2e31         	cmp	r6, #0x31
      4a: 0035         	movs	r5, r6
; void swap(char *arr, int i, int j) {
      4c: 7270         	strb	r0, [r6, #0x9]
      4e: 7665         	strb	r5, [r4, #0x19]
      50: 685f         	ldr	r7, [r3, #0x4]
      52: 6165         	str	r5, [r4, #0x14]
;   int temp = arr[i];
      54: 5f70         	ldrsh	r0, [r6, r5]
      56: 7470         	strb	r0, [r6, #0x11]
      58: 0072         	lsls	r2, r6, #0x1
      5a: 3072         	adds	r0, #0x72
;   arr[i] = arr[j];
      5c: 6800         	ldr	r0, [r0]
      5e: 6165         	str	r5, [r4, #0x14]
      60: 5f70         	ldrsh	r0, [r6, r5]
      62: 7470         	strb	r0, [r6, #0x11]
      64: 0072         	lsls	r2, r6, #0x1
;   arr[j] = temp;
      66: 7673         	strb	r3, [r6, #0x19]
      68: 5f63         	ldrsh	r3, [r4, r5]
      6a: 7865         	ldrb	r5, [r4, #0x1]
      6c: 7469         	strb	r1, [r5, #0x11]
; }
      6e: 6d00         	ldr	r0, [r0, #0x50]
      70: 6961         	ldr	r1, [r4, #0x14]
; void bubble_sort(char arr[], int n) {
      72: 006e         	lsls	r6, r5, #0x1
      74: 6574         	str	r4, [r6, #0x54]
      76: 706d         	strb	r5, [r5, #0x1]
      78: 6300         	str	r0, [r0, #0x30]
      7a: 6168         	str	r0, [r5, #0x14]
      7c: 0072         	lsls	r2, r6, #0x1
;   for (int i = 0; i < n; i++) {
      7e: 6e69         	ldr	r1, [r5, #0x64]
      80: 0074         	lsls	r4, r6, #0x1
      82: 6e75         	ldr	r5, [r6, #0x64]
      84: 6973         	ldr	r3, [r6, #0x14]
      86: 6e67         	ldr	r7, [r4, #0x64]
      88: 6465         	str	r5, [r4, #0x44]
      8a: 6920         	ldr	r0, [r4, #0x10]
      8c: 746e         	strb	r6, [r5, #0x11]
;     for (int j = 0; j < n - i - 1; j++) {
      8e: 6200         	str	r0, [r0, #0x20]
      90: 6275         	str	r5, [r6, #0x24]
      92: 6c62         	ldr	r2, [r4, #0x44]
      94: 5f65         	ldrsh	r5, [r4, r5]
      96: 6f73         	ldr	r3, [r6, #0x74]
      98: 7472         	strb	r2, [r6, #0x11]
      9a: 5f00         	ldrsh	r0, [r0, r4]
      9c: 415f         	adcs	r7, r3
      9e: 5252         	strh	r2, [r2, r1]
      a0: 5941         	ldr	r1, [r0, r5]
;       if (arr[j] > arr[j + 1])
      a2: 535f         	strh	r7, [r3, r5]
      a4: 5a49         	ldrh	r1, [r1, r1]
      a6: 5f45         	ldrsh	r5, [r0, r5]
      a8: 5954         	ldr	r4, [r2, r5]
      aa: 4550         	cmp	r0, r10
      ac: 5f5f         	ldrsh	r7, [r3, r5]
      ae: 7300         	strb	r0, [r0, #0xc]
      b0: 7262         	strb	r2, [r4, #0x9]
;         swap(arr, j, j + 1);
      b2: 006b         	lsls	r3, r5, #0x1
      b4: 3a43         	subs	r2, #0x43
      b6: 555c         	strb	r4, [r3, r5]
      b8: 6573         	str	r3, [r6, #0x54]
      ba: 7372         	strb	r2, [r6, #0xd]
      bc: 6b5c         	ldr	r4, [r3, #0x34]
;     }
      be: 7269         	strb	r1, [r5, #0x9]
;     for (int j = 0; j < n - i - 1; j++) {
      c0: 6e61         	ldr	r1, [r4, #0x64]
      c2: 445c         	add	r4, r11
      c4: 636f         	str	r7, [r5, #0x34]
      c6: 6d75         	ldr	r5, [r6, #0x54]
;   }
      c8: 6e65         	ldr	r5, [r4, #0x64]
;   for (int i = 0; i < n; i++) {
      ca: 7374         	strb	r4, [r6, #0xd]
      cc: 445c         	add	r4, r11
      ce: 7665         	strb	r5, [r4, #0x19]
      d0: 415c         	adcs	r4, r3
; }
      d2: 4143         	adcs	r3, r0
      d4: 705c         	strb	r4, [r3, #0x1]
; void assert_is_sorted(char *arr, unsigned n) {
      d6: 6f72         	ldr	r2, [r6, #0x74]
      d8: 7267         	strb	r7, [r4, #0x9]
      da: 6d61         	ldr	r1, [r4, #0x54]
      dc: 0073         	lsls	r3, r6, #0x1
      de: 6562         	str	r2, [r4, #0x54]
      e0: 636e         	str	r6, [r5, #0x34]
;   for (int i = 0; i < n - 1; i++) {
      e2: 6d68         	ldr	r0, [r5, #0x54]
      e4: 7261         	strb	r1, [r4, #0x9]
      e6: 736b         	strb	r3, [r5, #0xd]
      e8: 625c         	str	r4, [r3, #0x24]
      ea: 6275         	str	r5, [r6, #0x24]
      ec: 6c62         	ldr	r2, [r4, #0x44]
      ee: 2e65         	cmp	r6, #0x65
      f0: 0063         	lsls	r3, r4, #0x1
;     if (arr[i] > arr[i + 1]) {
      f2: 006a         	lsls	r2, r5, #0x1
      f4: 7261         	strb	r1, [r4, #0x9]
      f6: 0072         	lsls	r2, r6, #0x1

Disassembly of section .debug_addr:

00000000 <.debug_addr>:
; extern void* sbrk(ptrdiff_t increment) {
       0: 002c         	movs	r4, r5
       2: 0000         	movs	r0, r0
;     char* prev_heap_ptr = heap_ptr;
       4: 0005         	movs	r5, r0
       6: 0004         	movs	r4, r0
       8: 0000         	movs	r0, r0
;     if (increment > 0) {
       a: 2000         	movs	r0, #0x0
       c: 0000         	movs	r0, r0
       e: 0000         	movs	r0, r0
      10: 004c         	lsls	r4, r1, #0x1
;         if (heap_ptr + increment > &__heap_end) {
      12: 0000         	movs	r0, r0
      14: 0072         	lsls	r2, r6, #0x1
      16: 0000         	movs	r0, r0
      18: 007e         	lsls	r6, r7, #0x1
      1a: 0000         	movs	r0, r0
      1c: 008e         	lsls	r6, r1, #0x2
      1e: 0000         	movs	r0, r0
      20: 00d6         	lsls	r6, r2, #0x3
      22: 0000         	movs	r0, r0
      24: 00e2         	lsls	r2, r4, #0x3
;             return (void*)-1;  // Return error if the heap is full
      26: 0000         	movs	r0, r0
      28: 0118         	lsls	r0, r3, #0x4
;         heap_ptr += increment;
      2a: 0000         	movs	r0, r0
      2c: 0128         	lsls	r0, r5, #0x4
      2e: 0000         	movs	r0, r0

Disassembly of section .debug_line_str:

00000000 <.debug_line_str>:
; extern void* sbrk(ptrdiff_t increment) {
       0: 6562         	str	r2, [r4, #0x54]
       2: 636e         	str	r6, [r5, #0x34]
;     char* prev_heap_ptr = heap_ptr;
       4: 6d68         	ldr	r0, [r5, #0x54]
       6: 7261         	strb	r1, [r4, #0x9]
       8: 736b         	strb	r3, [r5, #0xd]
;     if (increment > 0) {
       a: 2e5c         	cmp	r6, #0x5c
       c: 2f2e         	cmp	r7, #0x2e
       e: 7973         	ldrb	r3, [r6, #0x5]
      10: 6373         	str	r3, [r6, #0x34]
;         if (heap_ptr + increment > &__heap_end) {
      12: 6c61         	ldr	r1, [r4, #0x44]
      14: 736c         	strb	r4, [r5, #0xd]
      16: 4c00         	ldr	r4, [pc, #0x0]          @ 0x18 <.debug_line+0x18>
      18: 564c         	ldrsb	r4, [r1, r1]
      1a: 2d4d         	cmp	r5, #0x4d
      1c: 5445         	strb	r5, [r0, r1]
      1e: 412d         	asrs	r5, r5
      20: 6d72         	ldr	r2, [r6, #0x54]
      22: 312d         	adds	r1, #0x2d
      24: 2e39         	cmp	r6, #0x39
;             return (void*)-1;  // Return error if the heap is full
      26: 2e31         	cmp	r6, #0x31
      28: 5c35         	ldrb	r5, [r6, r0]
;         heap_ptr += increment;
      2a: 696c         	ldr	r4, [r5, #0x14]
      2c: 5c62         	ldrb	r2, [r4, r1]
      2e: 6c63         	ldr	r3, [r4, #0x44]
      30: 6e61         	ldr	r1, [r4, #0x64]
      32: 5c67         	ldrb	r7, [r4, r1]
;     }
      34: 3931         	subs	r1, #0x31
;     return (void*)prev_heap_ptr;
      36: 695c         	ldr	r4, [r3, #0x14]
      38: 636e         	str	r6, [r5, #0x34]
      3a: 756c         	strb	r4, [r5, #0x15]
; }
      3c: 6564         	str	r4, [r4, #0x54]
      3e: 5f5c         	ldrsh	r4, [r3, r5]
      40: 735f         	strb	r7, [r3, #0xd]
      42: 6474         	str	r4, [r6, #0x44]
      44: 6564         	str	r4, [r4, #0x54]
      46: 5f66         	ldrsh	r6, [r4, r5]
      48: 7470         	strb	r0, [r6, #0x11]
      4a: 6472         	str	r2, [r6, #0x44]
; void swap(char *arr, int i, int j) {
      4c: 6669         	str	r1, [r5, #0x64]
      4e: 5f66         	ldrsh	r6, [r4, r5]
      50: 2e74         	cmp	r6, #0x74
      52: 0068         	lsls	r0, r5, #0x1
;   int temp = arr[i];
      54: 6562         	str	r2, [r4, #0x54]
      56: 636e         	str	r6, [r5, #0x34]
      58: 6d68         	ldr	r0, [r5, #0x54]
      5a: 7261         	strb	r1, [r4, #0x9]
;   arr[i] = arr[j];
      5c: 736b         	strb	r3, [r5, #0xd]
      5e: 6200         	str	r0, [r0, #0x20]
      60: 6275         	str	r5, [r6, #0x24]
      62: 6c62         	ldr	r2, [r4, #0x44]
      64: 2e65         	cmp	r6, #0x65
;   arr[j] = temp;
      66: 0063         	lsls	r3, r4, #0x1
      68: 3a43         	subs	r2, #0x43
      6a: 555c         	strb	r4, [r3, r5]
      6c: 6573         	str	r3, [r6, #0x54]
; }
      6e: 7372         	strb	r2, [r6, #0xd]
      70: 6b5c         	ldr	r4, [r3, #0x34]
; void bubble_sort(char arr[], int n) {
      72: 7269         	strb	r1, [r5, #0x9]
      74: 6e61         	ldr	r1, [r4, #0x64]
      76: 445c         	add	r4, r11
      78: 636f         	str	r7, [r5, #0x34]
      7a: 6d75         	ldr	r5, [r6, #0x54]
      7c: 6e65         	ldr	r5, [r4, #0x64]
;   for (int i = 0; i < n; i++) {
      7e: 7374         	strb	r4, [r6, #0xd]
      80: 445c         	add	r4, r11
      82: 7665         	strb	r5, [r4, #0x19]
      84: 415c         	adcs	r4, r3
      86: 4143         	adcs	r3, r0
      88: 705c         	strb	r4, [r3, #0x1]
      8a: 6f72         	ldr	r2, [r6, #0x74]
      8c: 7267         	strb	r7, [r4, #0x9]
;     for (int j = 0; j < n - i - 1; j++) {
      8e: 6d61         	ldr	r1, [r4, #0x54]
      90: 0073         	lsls	r3, r6, #0x1
      92: 3a43         	subs	r2, #0x43
      94: 555c         	strb	r4, [r3, r5]
      96: 6573         	str	r3, [r6, #0x54]
      98: 7372         	strb	r2, [r6, #0xd]
      9a: 6b5c         	ldr	r4, [r3, #0x34]
      9c: 7269         	strb	r1, [r5, #0x9]
      9e: 6e61         	ldr	r1, [r4, #0x64]
      a0: 6200         	str	r0, [r0, #0x20]
;       if (arr[j] > arr[j + 1])
      a2: 6e65         	ldr	r5, [r4, #0x64]
      a4: 6863         	ldr	r3, [r4, #0x4]
      a6: 616d         	str	r5, [r5, #0x14]
      a8: 6b72         	ldr	r2, [r6, #0x34]
      aa: 5c73         	ldrb	r3, [r6, r1]
      ac: 7562         	strb	r2, [r4, #0x15]
      ae: 6262         	str	r2, [r4, #0x24]
      b0: 656c         	str	r4, [r5, #0x54]
;         swap(arr, j, j + 1);
      b2: 632e         	str	r6, [r5, #0x30]
      b4: 7300         	strb	r0, [r0, #0xc]
      b6: 7379         	strb	r1, [r7, #0xd]
      b8: 6163         	str	r3, [r4, #0x14]
      ba: 6c6c         	ldr	r4, [r5, #0x44]
      bc: 2e73         	cmp	r6, #0x73
;     }
      be: 0068         	lsls	r0, r5, #0x1

Disassembly of section .debug_str_offsets:

00000000 <.debug_str_offsets>:
; extern void* sbrk(ptrdiff_t increment) {
       0: 0068         	lsls	r0, r5, #0x1
       2: 0000         	movs	r0, r0
;     char* prev_heap_ptr = heap_ptr;
       4: 0005         	movs	r5, r0
       6: 0000         	movs	r0, r0
       8: 0037         	movs	r7, r6
;     if (increment > 0) {
       a: 0000         	movs	r0, r0
       c: 00de         	lsls	r6, r3, #0x3
       e: 0000         	movs	r0, r0
      10: 00b4         	lsls	r4, r6, #0x2
;         if (heap_ptr + increment > &__heap_end) {
      12: 0000         	movs	r0, r0
      14: 005d         	lsls	r5, r3, #0x1
      16: 0000         	movs	r0, r0
      18: 0079         	lsls	r1, r7, #0x1
      1a: 0000         	movs	r0, r0
      1c: 00af         	lsls	r7, r5, #0x2
      1e: 0000         	movs	r0, r0
      20: 0032         	movs	r2, r6
      22: 0000         	movs	r0, r0
      24: 008f         	lsls	r7, r1, #0x2
;             return (void*)-1;  // Return error if the heap is full
      26: 0000         	movs	r0, r0
      28: 0000         	movs	r0, r0
;         heap_ptr += increment;
      2a: 0000         	movs	r0, r0
      2c: 0066         	lsls	r6, r4, #0x1
      2e: 0000         	movs	r0, r0
      30: 006f         	lsls	r7, r5, #0x1
      32: 0000         	movs	r0, r0
;     }
      34: 007e         	lsls	r6, r7, #0x1
;     return (void*)prev_heap_ptr;
      36: 0000         	movs	r0, r0
      38: 0011         	movs	r1, r2
      3a: 0000         	movs	r0, r0
; }
      3c: 0026         	movs	r6, r4
      3e: 0000         	movs	r0, r0
      40: 004c         	lsls	r4, r1, #0x1
      42: 0000         	movs	r0, r0
      44: 00f4         	lsls	r4, r6, #0x3
      46: 0000         	movs	r0, r0
      48: 001b         	movs	r3, r3
      4a: 0000         	movs	r0, r0
; void swap(char *arr, int i, int j) {
      4c: 00f2         	lsls	r2, r6, #0x3
      4e: 0000         	movs	r0, r0
      50: 0074         	lsls	r4, r6, #0x1
      52: 0000         	movs	r0, r0
;   int temp = arr[i];
      54: 0030         	movs	r0, r6
      56: 0000         	movs	r0, r0
      58: 0082         	lsls	r2, r0, #0x2
      5a: 0000         	movs	r0, r0
;   arr[i] = arr[j];
      5c: 0021         	movs	r1, r4
      5e: 0000         	movs	r0, r0
      60: 005a         	lsls	r2, r3, #0x1
      62: 0000         	movs	r0, r0
      64: 009b         	lsls	r3, r3, #0x2
;   arr[j] = temp;
      66: 0000         	movs	r0, r0
      68: 001d         	movs	r5, r3
      6a: 0000         	movs	r0, r0

Disassembly of section .ARM.attributes:

00000000 <.ARM.attributes>:
; extern void* sbrk(ptrdiff_t increment) {
       0: 4041         	eors	r1, r0
       2: 0000         	movs	r0, r0
;     char* prev_heap_ptr = heap_ptr;
       4: 6100         	str	r0, [r0, #0x10]
       6: 6165         	str	r5, [r4, #0x14]
       8: 6962         	ldr	r2, [r4, #0x14]
;     if (increment > 0) {
       a: 0100         	lsls	r0, r0, #0x4
       c: 0036         	movs	r6, r6
       e: 0000         	movs	r0, r0
      10: 3243         	adds	r2, #0x43
;         if (heap_ptr + increment > &__heap_end) {
      12: 302e         	adds	r0, #0x2e
      14: 0039         	movs	r1, r7
      16: 6305         	str	r5, [r0, #0x30]
      18: 726f         	strb	r7, [r5, #0x9]
      1a: 6574         	str	r4, [r6, #0x54]
      1c: 2d78         	cmp	r5, #0x78
      1e: 306d         	adds	r0, #0x6d
      20: 0600         	lsls	r0, r0, #0x18
      22: 070c         	lsls	r4, r1, #0x1c
      24: 084d         	lsrs	r5, r1, #0x1
;             return (void*)-1;  // Return error if the heap is full
      26: 0900         	lsrs	r0, r0, #0x4
      28: 0e01         	lsrs	r1, r0, #0x18
;         heap_ptr += increment;
      2a: 1100         	asrs	r0, r0, #0x4
      2c: 1201         	asrs	r1, r0, #0x8
      2e: 1404         	asrs	r4, r0, #0x10
      30: 1501         	asrs	r1, r0, #0x14
      32: 1700         	asrs	r0, r0, #0x1c
;     }
      34: 1803         	adds	r3, r0, r0
;     return (void*)prev_heap_ptr;
      36: 1901         	adds	r1, r0, r4
      38: 1a01         	subs	r1, r0, r0
      3a: 1e02         	subs	r2, r0, #0x0
; }
      3c: 2206         	movs	r2, #0x6
      3e: 2600         	movs	r6, #0x0
      40: 01           	<unknown>

Disassembly of section .symtab:

00000000 <.symtab>:
		...
;     if (increment > 0) {
      10: 0001         	movs	r1, r0
		...
;         if (heap_ptr + increment > &__heap_end) {
      1a: 0000         	movs	r0, r0
      1c: 0004         	movs	r4, r0
      1e: fff1 000a    	<unknown>
		...
;         heap_ptr += increment;
      2e: 0001         	movs	r1, r0
      30: 000d         	movs	r5, r1
      32: 0000         	movs	r0, r0
;     }
      34: 0044         	lsls	r4, r0, #0x1
		...
; }
      3e: 0001         	movs	r1, r0
      40: 0010         	movs	r0, r2
      42: 0000         	movs	r0, r0
      44: 0000         	movs	r0, r0
      46: 2000         	movs	r0, #0x0
      48: 0004         	movs	r4, r0
      4a: 0000         	movs	r0, r0
; void swap(char *arr, int i, int j) {
      4c: 0001         	movs	r1, r0
      4e: 0003         	movs	r3, r0
      50: 0019         	movs	r1, r3
      52: 0000         	movs	r0, r0
;   int temp = arr[i];
      54: 004c         	lsls	r4, r1, #0x1
		...
;   arr[i] = arr[j];
      5e: 0001         	movs	r1, r0
      60: 001c         	movs	r4, r3
      62: 0000         	movs	r0, r0
      64: 0119         	lsls	r1, r3, #0x4
;   arr[j] = temp;
      66: 0000         	movs	r0, r0
      68: 0010         	movs	r0, r2
      6a: 0000         	movs	r0, r0
      6c: 0002         	movs	r2, r0
; }
      6e: 0001         	movs	r1, r0
      70: 0025         	movs	r5, r4
; void bubble_sort(char arr[], int n) {
      72: 0000         	movs	r0, r0
      74: 0160         	lsls	r0, r4, #0x5
		...
;   for (int i = 0; i < n; i++) {
      7e: 0001         	movs	r1, r0
      80: 006c         	lsls	r4, r5, #0x1
		...
      8a: 0000         	movs	r0, r0
      8c: 0200         	lsls	r0, r0, #0x8
;     for (int j = 0; j < n - i - 1; j++) {
      8e: 0001         	movs	r1, r0
      90: 0028         	movs	r0, r5
      92: 0000         	movs	r0, r0
      94: 0001         	movs	r1, r0
      96: 0000         	movs	r0, r0
      98: 004c         	lsls	r4, r1, #0x1
      9a: 0000         	movs	r0, r0
      9c: 0012         	movs	r2, r2
      9e: 0001         	movs	r1, r0
      a0: 002d         	movs	r5, r5
;       if (arr[j] > arr[j + 1])
      a2: 0000         	movs	r0, r0
      a4: 0000         	movs	r0, r0
      a6: 21f8         	movs	r1, #0xf8
      a8: 0000         	movs	r0, r0
      aa: 0000         	movs	r0, r0
      ac: 0010         	movs	r0, r2
      ae: fff1 0038    	<unknown>
;         swap(arr, j, j + 1);
      b2: 0000         	movs	r0, r0
      b4: 004d         	lsls	r5, r1, #0x1
      b6: 0000         	movs	r0, r0
      b8: 0026         	movs	r6, r4
      ba: 0000         	movs	r0, r0
      bc: 0012         	movs	r2, r2
;     }
      be: 0001         	movs	r1, r0
;     for (int j = 0; j < n - i - 1; j++) {
      c0: 003d         	movs	r5, r7
      c2: 0000         	movs	r0, r0
      c4: 0073         	lsls	r3, r6, #0x1
      c6: 0000         	movs	r0, r0
;   }
      c8: 0064         	lsls	r4, r4, #0x1
;   for (int i = 0; i < n; i++) {
      ca: 0000         	movs	r0, r0
      cc: 0012         	movs	r2, r2
      ce: 0001         	movs	r1, r0
      d0: 0049         	lsls	r1, r1, #0x1
; }
      d2: 0000         	movs	r0, r0
      d4: 00d7         	lsls	r7, r2, #0x3
; void assert_is_sorted(char *arr, unsigned n) {
      d6: 0000         	movs	r0, r0
      d8: 0042         	lsls	r2, r0, #0x1
      da: 0000         	movs	r0, r0
      dc: 0012         	movs	r2, r2
      de: 0001         	movs	r1, r0
      e0: 005a         	lsls	r2, r3, #0x1
;   for (int i = 0; i < n - 1; i++) {
      e2: 0000         	movs	r0, r0
      e4: 0129         	lsls	r1, r5, #0x4
      e6: 0000         	movs	r0, r0
      e8: 0040         	lsls	r0, r0, #0x1
      ea: 0000         	movs	r0, r0
      ec: 0012         	movs	r2, r2
      ee: 0001         	movs	r1, r0
      f0: 005f         	lsls	r7, r3, #0x1
;     if (arr[i] > arr[i + 1]) {
      f2: 0000         	movs	r0, r0
      f4: 0008         	movs	r0, r1
      f6: 2000         	movs	r0, #0x0
      f8: 0000         	movs	r0, r0
      fa: 0000         	movs	r0, r0
      fc: 0010         	movs	r0, r2
      fe: 0006         	movs	r6, r0
     100: 0079         	lsls	r1, r7, #0x1
		...
;   }
     10a: 0000         	movs	r0, r0
;   for (int i = 0; i < n - 1; i++) {
     10c: 0010         	movs	r0, r2
     10e: fff1 0081    	<unknown>
     112: 0000         	movs	r0, r0
; }
     114: 0000         	movs	r0, r0
     116: 0010         	movs	r0, r2
; static inline void svc_exit(unsigned code) {
     118: 0000         	movs	r0, r0
     11a: 0000         	movs	r0, r0
;     register unsigned r0 __asm__("r0") = code;
     11c: 0010         	movs	r0, r2
     11e: fff1 008e    	<unknown>
;     __asm volatile ("svc 0" :  : "r"(r0) : "memory");
     122: 0000         	movs	r0, r0
; };
     124: 0000         	movs	r0, r0
     126: 2000         	movs	r0, #0x0
; int main() {
     128: 0000         	movs	r0, r0
     12a: 0000         	movs	r0, r0
     12c: 0010         	movs	r0, r2
     12e: fff1 0094    	<unknown>
     132: 0000         	movs	r0, r0
;   char arr[] = {
     134: 0000         	movs	r0, r0
     136: 0200         	lsls	r0, r0, #0x8
     138: 0000         	movs	r0, r0
     13a: 0000         	movs	r0, r0
     13c: 0010         	movs	r0, r2
     13e: fff1 009f    	<unknown>
;   unsigned len = sizeof(arr) / sizeof(char);
     142: 0000         	movs	r0, r0
;   bubble_sort(arr, len);
     144: 0001         	movs	r1, r0
     146: 0000         	movs	r0, r0
     148: 0000         	movs	r0, r0
     14a: 0000         	movs	r0, r0
;   assert_is_sorted(arr, len);
     14c: 0010         	movs	r0, r2
     14e: fff1 00ab    	<unknown>
     152: 0000         	movs	r0, r0
;   svc_exit(arr[0]);
     154: 0008         	movs	r0, r1
     156: 2000         	movs	r0, #0x0
     158: 0000         	movs	r0, r0
     15a: 0000         	movs	r0, r0
; }
     15c: 0010         	movs	r0, r2
     15e: 0006         	movs	r6, r0
     160: 00b5         	lsls	r5, r6, #0x2
     162: 0000         	movs	r0, r0
     164: 0000         	movs	r0, r0
     166: 0008         	movs	r0, r1
     168: 0000         	movs	r0, r0
     16a: 0000         	movs	r0, r0
     16c: 0010         	movs	r0, r2
     16e: fff1 00c5    	<unknown>
     172: 0000         	movs	r0, r0
     174: 0000         	movs	r0, r0
     176: 0008         	movs	r0, r1
     178: 0000         	movs	r0, r0
     17a: 0000         	movs	r0, r0
     17c: 0010         	movs	r0, r2
     17e: fff1 00d2    	<unknown>
     182: 0000         	movs	r0, r0
     184: 0008         	movs	r0, r1
     186: 0000         	movs	r0, r0
     188: 0000         	movs	r0, r0
     18a: 0000         	movs	r0, r0
     18c: 0010         	movs	r0, r2
     18e: fff1 00de    	<unknown>
     192: 0000         	movs	r0, r0
     194: 0008         	movs	r0, r1
     196: 0000         	movs	r0, r0
     198: 0000         	movs	r0, r0
     19a: 0000         	movs	r0, r0
     19c: 0010         	movs	r0, r2
     19e: fff1 00f1    	<unknown>
     1a2: 0000         	movs	r0, r0
     1a4: 0000         	movs	r0, r0
     1a6: 2200         	movs	r2, #0x0
     1a8: 0000         	movs	r0, r0
     1aa: 0000         	movs	r0, r0
     1ac: 0010         	movs	r0, r2
     1ae: fff1 00f9    	<unknown>
     1b2: 0000         	movs	r0, r0
     1b4: 0008         	movs	r0, r1
     1b6: 2000         	movs	r0, #0x0
     1b8: 0000         	movs	r0, r0
     1ba: 0000         	movs	r0, r0
     1bc: 0010         	movs	r0, r2
     1be: 0006         	movs	r6, r0
     1c0: 00ff         	lsls	r7, r7, #0x3
     1c2: 0000         	movs	r0, r0
     1c4: 017c         	lsls	r4, r7, #0x5
     1c6: 0000         	movs	r0, r0
     1c8: 0000         	movs	r0, r0
     1ca: 0000         	movs	r0, r0
     1cc: 0010         	movs	r0, r2
     1ce: fff1 0111    	<unknown>
     1d2: 0000         	movs	r0, r0
     1d4: 0174         	lsls	r4, r6, #0x5
     1d6: 0000         	movs	r0, r0
     1d8: 0000         	movs	r0, r0
     1da: 0000         	movs	r0, r0
     1dc: 0010         	movs	r0, r2
     1de: fff1 011f    	<unknown>
     1e2: 0000         	movs	r0, r0
     1e4: 017c         	lsls	r4, r7, #0x5
     1e6: 0000         	movs	r0, r0
     1e8: 0000         	movs	r0, r0
     1ea: 0000         	movs	r0, r0
     1ec: 0010         	movs	r0, r2
     1ee: fff1 0132    	<unknown>
     1f2: 0000         	movs	r0, r0
     1f4: 0008         	movs	r0, r1
     1f6: 2000         	movs	r0, #0x0
     1f8: 0000         	movs	r0, r0
     1fa: 0000         	movs	r0, r0
     1fc: 0010         	movs	r0, r2
     1fe: 0004         	movs	r4, r0
     200: 013d         	lsls	r5, r7, #0x4
     202: 0000         	movs	r0, r0
     204: 0000         	movs	r0, r0
     206: 2000         	movs	r0, #0x0
     208: 0000         	movs	r0, r0
     20a: 0000         	movs	r0, r0
     20c: 0010         	movs	r0, r2
     20e: 0003         	movs	r3, r0
     210: 014a         	lsls	r2, r1, #0x5
     212: 0000         	movs	r0, r0
     214: 0168         	lsls	r0, r5, #0x5
     216: 0000         	movs	r0, r0
     218: 0000         	movs	r0, r0
     21a: 0000         	movs	r0, r0
     21c: 0010         	movs	r0, r2
     21e: 0001         	movs	r1, r0
     220: 0155         	lsls	r5, r2, #0x5
     222: 0000         	movs	r0, r0
     224: 0008         	movs	r0, r1
     226: 2000         	movs	r0, #0x0
     228: 0000         	movs	r0, r0
     22a: 0000         	movs	r0, r0
     22c: 0010         	movs	r0, r2
     22e: 0006         	movs	r6, r0

Disassembly of section .shstrtab:

00000000 <.shstrtab>:
; extern void* sbrk(ptrdiff_t increment) {
       0: 2e00         	cmp	r6, #0x0
       2: 6574         	str	r4, [r6, #0x54]
;     char* prev_heap_ptr = heap_ptr;
       4: 7478         	strb	r0, [r7, #0x11]
       6: 2e00         	cmp	r6, #0x0
       8: 6f72         	ldr	r2, [r6, #0x74]
;     if (increment > 0) {
       a: 6164         	str	r4, [r4, #0x14]
       c: 6174         	str	r4, [r6, #0x14]
       e: 2e00         	cmp	r6, #0x0
      10: 6164         	str	r4, [r4, #0x14]
;         if (heap_ptr + increment > &__heap_end) {
      12: 6174         	str	r4, [r6, #0x14]
      14: 2e00         	cmp	r6, #0x0
      16: 6474         	str	r4, [r6, #0x44]
      18: 7461         	strb	r1, [r4, #0x11]
      1a: 0061         	lsls	r1, r4, #0x1
      1c: 742e         	strb	r6, [r5, #0x10]
      1e: 7362         	strb	r2, [r4, #0xd]
      20: 0073         	lsls	r3, r6, #0x1
      22: 622e         	str	r6, [r5, #0x20]
      24: 7373         	strb	r3, [r6, #0xd]
;             return (void*)-1;  // Return error if the heap is full
      26: 2e00         	cmp	r6, #0x0
      28: 6568         	str	r0, [r5, #0x54]
;         heap_ptr += increment;
      2a: 7061         	strb	r1, [r4, #0x1]
      2c: 2e00         	cmp	r6, #0x0
      2e: 7473         	strb	r3, [r6, #0x11]
      30: 6361         	str	r1, [r4, #0x34]
      32: 006b         	lsls	r3, r5, #0x1
;     }
      34: 632e         	str	r6, [r5, #0x30]
;     return (void*)prev_heap_ptr;
      36: 6d6f         	ldr	r7, [r5, #0x54]
      38: 656d         	str	r5, [r5, #0x54]
      3a: 746e         	strb	r6, [r5, #0x11]
; }
      3c: 2e00         	cmp	r6, #0x0
      3e: 6564         	str	r4, [r4, #0x54]
      40: 7562         	strb	r2, [r4, #0x15]
      42: 5f67         	ldrsh	r7, [r4, r5]
      44: 6e69         	ldr	r1, [r5, #0x64]
      46: 6f66         	ldr	r6, [r4, #0x74]
      48: 2e00         	cmp	r6, #0x0
      4a: 6564         	str	r4, [r4, #0x54]
; void swap(char *arr, int i, int j) {
      4c: 7562         	strb	r2, [r4, #0x15]
      4e: 5f67         	ldrsh	r7, [r4, r5]
      50: 6261         	str	r1, [r4, #0x24]
      52: 7262         	strb	r2, [r4, #0x9]
;   int temp = arr[i];
      54: 7665         	strb	r5, [r4, #0x19]
      56: 2e00         	cmp	r6, #0x0
      58: 6564         	str	r4, [r4, #0x54]
      5a: 7562         	strb	r2, [r4, #0x15]
;   arr[i] = arr[j];
      5c: 5f67         	ldrsh	r7, [r4, r5]
      5e: 696c         	ldr	r4, [r5, #0x14]
      60: 656e         	str	r6, [r5, #0x54]
      62: 2e00         	cmp	r6, #0x0
      64: 6564         	str	r4, [r4, #0x54]
;   arr[j] = temp;
      66: 7562         	strb	r2, [r4, #0x15]
      68: 5f67         	ldrsh	r7, [r4, r5]
      6a: 7266         	strb	r6, [r4, #0x9]
      6c: 6d61         	ldr	r1, [r4, #0x54]
; }
      6e: 0065         	lsls	r5, r4, #0x1
      70: 642e         	str	r6, [r5, #0x40]
; void bubble_sort(char arr[], int n) {
      72: 6265         	str	r5, [r4, #0x24]
      74: 6775         	str	r5, [r6, #0x74]
      76: 735f         	strb	r7, [r3, #0xd]
      78: 7274         	strb	r4, [r6, #0x9]
      7a: 2e00         	cmp	r6, #0x0
      7c: 6564         	str	r4, [r4, #0x54]
;   for (int i = 0; i < n; i++) {
      7e: 7562         	strb	r2, [r4, #0x15]
      80: 5f67         	ldrsh	r7, [r4, r5]
      82: 6461         	str	r1, [r4, #0x44]
      84: 7264         	strb	r4, [r4, #0x9]
      86: 2e00         	cmp	r6, #0x0
      88: 6564         	str	r4, [r4, #0x54]
      8a: 7562         	strb	r2, [r4, #0x15]
      8c: 5f67         	ldrsh	r7, [r4, r5]
;     for (int j = 0; j < n - i - 1; j++) {
      8e: 696c         	ldr	r4, [r5, #0x14]
      90: 656e         	str	r6, [r5, #0x54]
      92: 735f         	strb	r7, [r3, #0xd]
      94: 7274         	strb	r4, [r6, #0x9]
      96: 2e00         	cmp	r6, #0x0
      98: 6564         	str	r4, [r4, #0x54]
      9a: 7562         	strb	r2, [r4, #0x15]
      9c: 5f67         	ldrsh	r7, [r4, r5]
      9e: 7473         	strb	r3, [r6, #0x11]
      a0: 5f72         	ldrsh	r2, [r6, r5]
;       if (arr[j] > arr[j + 1])
      a2: 666f         	str	r7, [r5, #0x64]
      a4: 7366         	strb	r6, [r4, #0xd]
      a6: 7465         	strb	r5, [r4, #0x11]
      a8: 0073         	lsls	r3, r6, #0x1
      aa: 412e         	asrs	r6, r5
      ac: 4d52         	ldr	r5, [pc, #0x148]        @ 0x1f8 <.rodata+0x90>
      ae: 612e         	str	r6, [r5, #0x10]
      b0: 7474         	strb	r4, [r6, #0x11]
;         swap(arr, j, j + 1);
      b2: 6972         	ldr	r2, [r6, #0x14]
      b4: 7562         	strb	r2, [r4, #0x15]
      b6: 6574         	str	r4, [r6, #0x54]
      b8: 0073         	lsls	r3, r6, #0x1
      ba: 732e         	strb	r6, [r5, #0xc]
      bc: 6d79         	ldr	r1, [r7, #0x54]
;     }
      be: 6174         	str	r4, [r6, #0x14]
;     for (int j = 0; j < n - i - 1; j++) {
      c0: 0062         	lsls	r2, r4, #0x1
      c2: 732e         	strb	r6, [r5, #0xc]
      c4: 7368         	strb	r0, [r5, #0xd]
      c6: 7274         	strb	r4, [r6, #0x9]
;   }
      c8: 6174         	str	r4, [r6, #0x14]
;   for (int i = 0; i < n; i++) {
      ca: 0062         	lsls	r2, r4, #0x1
      cc: 732e         	strb	r6, [r5, #0xc]
      ce: 7274         	strb	r4, [r6, #0x9]
      d0: 6174         	str	r4, [r6, #0x14]
; }
      d2: 0062         	lsls	r2, r4, #0x1

Disassembly of section .strtab:

00000000 <.strtab>:
; extern void* sbrk(ptrdiff_t increment) {
       0: 6200         	str	r0, [r0, #0x20]
       2: 6275         	str	r5, [r6, #0x24]
;     char* prev_heap_ptr = heap_ptr;
       4: 6c62         	ldr	r2, [r4, #0x44]
       6: 2e65         	cmp	r6, #0x65
       8: 0063         	lsls	r3, r4, #0x1
;     if (increment > 0) {
       a: 7424         	strb	r4, [r4, #0x10]
       c: 2400         	movs	r4, #0x0
       e: 0064         	lsls	r4, r4, #0x1
      10: 6568         	str	r0, [r5, #0x54]
;         if (heap_ptr + increment > &__heap_end) {
      12: 7061         	strb	r1, [r4, #0x1]
      14: 705f         	strb	r7, [r3, #0x1]
      16: 7274         	strb	r4, [r6, #0x9]
      18: 2400         	movs	r4, #0x0
      1a: 0074         	lsls	r4, r6, #0x1
      1c: 7673         	strb	r3, [r6, #0x19]
      1e: 5f63         	ldrsh	r3, [r4, r5]
      20: 7865         	ldrb	r5, [r4, #0x1]
      22: 7469         	strb	r1, [r5, #0x11]
      24: 2400         	movs	r4, #0x0
;             return (void*)-1;  // Return error if the heap is full
      26: 0064         	lsls	r4, r4, #0x1
      28: 6273         	str	r3, [r6, #0x24]
;         heap_ptr += increment;
      2a: 6b72         	ldr	r2, [r6, #0x34]
      2c: 5f00         	ldrsh	r0, [r0, r4]
      2e: 685f         	ldr	r7, [r3, #0x4]
      30: 6165         	str	r5, [r4, #0x14]
      32: 5f70         	ldrsh	r0, [r6, r5]
;     }
      34: 6e65         	ldr	r5, [r4, #0x64]
;     return (void*)prev_heap_ptr;
      36: 0064         	lsls	r4, r4, #0x1
      38: 7773         	strb	r3, [r6, #0x1d]
      3a: 7061         	strb	r1, [r4, #0x1]
; }
      3c: 6200         	str	r0, [r0, #0x20]
      3e: 6275         	str	r5, [r6, #0x24]
      40: 6c62         	ldr	r2, [r4, #0x44]
      42: 5f65         	ldrsh	r5, [r4, r5]
      44: 6f73         	ldr	r3, [r6, #0x74]
      46: 7472         	strb	r2, [r6, #0x11]
      48: 6100         	str	r0, [r0, #0x10]
      4a: 7373         	strb	r3, [r6, #0xd]
; void swap(char *arr, int i, int j) {
      4c: 7265         	strb	r5, [r4, #0x9]
      4e: 5f74         	ldrsh	r4, [r6, r5]
      50: 7369         	strb	r1, [r5, #0xd]
      52: 735f         	strb	r7, [r3, #0xd]
;   int temp = arr[i];
      54: 726f         	strb	r7, [r5, #0x9]
      56: 6574         	str	r4, [r6, #0x54]
      58: 0064         	lsls	r4, r4, #0x1
      5a: 616d         	str	r5, [r5, #0x14]
;   arr[i] = arr[j];
      5c: 6e69         	ldr	r1, [r5, #0x64]
      5e: 5f00         	ldrsh	r0, [r0, r4]
      60: 685f         	ldr	r7, [r3, #0x4]
      62: 6165         	str	r5, [r4, #0x14]
      64: 5f70         	ldrsh	r0, [r6, r5]
;   arr[j] = temp;
      66: 7473         	strb	r3, [r6, #0x11]
      68: 7261         	strb	r1, [r4, #0x9]
      6a: 0074         	lsls	r4, r6, #0x1
      6c: 5f5f         	ldrsh	r7, [r3, r5]
; }
      6e: 7364         	strb	r4, [r4, #0xd]
      70: 5f6f         	ldrsh	r7, [r5, r5]
; void bubble_sort(char arr[], int n) {
      72: 6168         	str	r0, [r5, #0x14]
      74: 646e         	str	r6, [r5, #0x44]
      76: 656c         	str	r4, [r5, #0x54]
      78: 5f00         	ldrsh	r0, [r0, r4]
      7a: 665f         	str	r7, [r3, #0x64]
      7c: 616c         	str	r4, [r5, #0x14]
;   for (int i = 0; i < n; i++) {
      7e: 6873         	ldr	r3, [r6, #0x4]
      80: 5f00         	ldrsh	r0, [r0, r4]
      82: 665f         	str	r7, [r3, #0x64]
      84: 616c         	str	r4, [r5, #0x14]
      86: 6873         	ldr	r3, [r6, #0x4]
      88: 735f         	strb	r7, [r3, #0xd]
      8a: 7a69         	ldrb	r1, [r5, #0x9]
      8c: 0065         	lsls	r5, r4, #0x1
;     for (int j = 0; j < n - i - 1; j++) {
      8e: 5f5f         	ldrsh	r7, [r3, r5]
      90: 6172         	str	r2, [r6, #0x14]
      92: 006d         	lsls	r5, r5, #0x1
      94: 5f5f         	ldrsh	r7, [r3, r5]
      96: 6172         	str	r2, [r6, #0x14]
      98: 5f6d         	ldrsh	r5, [r5, r5]
      9a: 6973         	ldr	r3, [r6, #0x14]
      9c: 657a         	str	r2, [r7, #0x54]
      9e: 5f00         	ldrsh	r0, [r0, r4]
      a0: 745f         	strb	r7, [r3, #0x11]
;       if (arr[j] > arr[j + 1])
      a2: 736c         	strb	r4, [r5, #0xd]
      a4: 615f         	str	r7, [r3, #0x14]
      a6: 696c         	ldr	r4, [r5, #0x14]
      a8: 6e67         	ldr	r7, [r4, #0x64]
      aa: 5f00         	ldrsh	r0, [r0, r4]
      ac: 625f         	str	r7, [r3, #0x24]
      ae: 7373         	strb	r3, [r6, #0xd]
      b0: 655f         	str	r7, [r3, #0x54]
;         swap(arr, j, j + 1);
      b2: 646e         	str	r6, [r5, #0x44]
      b4: 5f00         	ldrsh	r0, [r0, r4]
      b6: 685f         	ldr	r7, [r3, #0x4]
      b8: 6165         	str	r5, [r4, #0x14]
      ba: 5f70         	ldrsh	r0, [r6, r5]
      bc: 6973         	ldr	r3, [r6, #0x14]
;     }
      be: 657a         	str	r2, [r7, #0x54]
;     for (int j = 0; j < n - i - 1; j++) {
      c0: 6d5f         	ldr	r7, [r3, #0x54]
      c2: 6e69         	ldr	r1, [r5, #0x64]
      c4: 5f00         	ldrsh	r0, [r0, r4]
      c6: 735f         	strb	r7, [r3, #0xd]
;   }
      c8: 6174         	str	r4, [r6, #0x14]
;   for (int i = 0; i < n; i++) {
      ca: 6b63         	ldr	r3, [r4, #0x34]
      cc: 735f         	strb	r7, [r3, #0xd]
      ce: 7a69         	ldrb	r1, [r5, #0x9]
      d0: 0065         	lsls	r5, r4, #0x1
; }
      d2: 5f5f         	ldrsh	r7, [r3, r5]
      d4: 6164         	str	r4, [r4, #0x14]
; void assert_is_sorted(char *arr, unsigned n) {
      d6: 6174         	str	r4, [r6, #0x14]
      d8: 735f         	strb	r7, [r3, #0xd]
      da: 7a69         	ldrb	r1, [r5, #0x9]
      dc: 0065         	lsls	r5, r4, #0x1
      de: 5f5f         	ldrsh	r7, [r3, r5]
      e0: 6164         	str	r4, [r4, #0x14]
;   for (int i = 0; i < n - 1; i++) {
      e2: 6174         	str	r4, [r6, #0x14]
      e4: 735f         	strb	r7, [r3, #0xd]
      e6: 756f         	strb	r7, [r5, #0x15]
      e8: 6372         	str	r2, [r6, #0x34]
      ea: 5f65         	ldrsh	r5, [r4, r5]
      ec: 6973         	ldr	r3, [r6, #0x14]
      ee: 657a         	str	r2, [r7, #0x54]
      f0: 5f00         	ldrsh	r0, [r0, r4]
;     if (arr[i] > arr[i + 1]) {
      f2: 735f         	strb	r7, [r3, #0xd]
      f4: 6174         	str	r4, [r6, #0x14]
      f6: 6b63         	ldr	r3, [r4, #0x34]
      f8: 5f00         	ldrsh	r0, [r0, r4]
      fa: 655f         	str	r7, [r3, #0x54]
      fc: 646e         	str	r6, [r5, #0x44]
      fe: 5f00         	ldrsh	r0, [r0, r4]
     100: 645f         	str	r7, [r3, #0x44]
     102: 7461         	strb	r1, [r4, #0x11]
;       svc_exit(1);
     104: 5f61         	ldrsh	r1, [r4, r5]
     106: 6f73         	ldr	r3, [r6, #0x74]
;     }
     108: 7275         	strb	r5, [r6, #0x9]
;   }
     10a: 6563         	str	r3, [r4, #0x54]
;   for (int i = 0; i < n - 1; i++) {
     10c: 655f         	str	r7, [r3, #0x54]
     10e: 646e         	str	r6, [r5, #0x44]
     110: 5f00         	ldrsh	r0, [r0, r4]
     112: 645f         	str	r7, [r3, #0x44]
; }
     114: 7461         	strb	r1, [r4, #0x11]
     116: 5f61         	ldrsh	r1, [r4, r5]
; static inline void svc_exit(unsigned code) {
     118: 6f73         	ldr	r3, [r6, #0x74]
     11a: 7275         	strb	r5, [r6, #0x9]
;     register unsigned r0 __asm__("r0") = code;
     11c: 6563         	str	r3, [r4, #0x54]
     11e: 5f00         	ldrsh	r0, [r0, r4]
;     __asm volatile ("svc 0" :  : "r"(r0) : "memory");
     120: 745f         	strb	r7, [r3, #0x11]
     122: 6164         	str	r4, [r4, #0x14]
; };
     124: 6174         	str	r4, [r6, #0x14]
     126: 735f         	strb	r7, [r3, #0xd]
; int main() {
     128: 756f         	strb	r7, [r5, #0x15]
     12a: 6372         	str	r2, [r6, #0x34]
     12c: 5f65         	ldrsh	r5, [r4, r5]
     12e: 6e65         	ldr	r5, [r4, #0x64]
     130: 0064         	lsls	r4, r4, #0x1
     132: 5f5f         	ldrsh	r7, [r3, r5]
;   char arr[] = {
     134: 6164         	str	r4, [r4, #0x14]
     136: 6174         	str	r4, [r6, #0x14]
     138: 655f         	str	r7, [r3, #0x54]
     13a: 646e         	str	r6, [r5, #0x44]
     13c: 5f00         	ldrsh	r0, [r0, r4]
     13e: 645f         	str	r7, [r3, #0x44]
     140: 7461         	strb	r1, [r4, #0x11]
;   unsigned len = sizeof(arr) / sizeof(char);
     142: 5f61         	ldrsh	r1, [r4, r5]
;   bubble_sort(arr, len);
     144: 7473         	strb	r3, [r6, #0x11]
     146: 7261         	strb	r1, [r4, #0x9]
     148: 0074         	lsls	r4, r6, #0x1
     14a: 5f5f         	ldrsh	r7, [r3, r5]
;   assert_is_sorted(arr, len);
     14c: 6574         	str	r4, [r6, #0x54]
     14e: 7478         	strb	r0, [r7, #0x11]
     150: 655f         	str	r7, [r3, #0x54]
     152: 646e         	str	r6, [r5, #0x44]
;   svc_exit(arr[0]);
     154: 5f00         	ldrsh	r0, [r0, r4]
     156: 6e65         	ldr	r5, [r4, #0x64]
     158: 0064         	lsls	r4, r4, #0x1
